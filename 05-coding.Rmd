# (PART) Style Guide-Coding {-}

# Coding Style {#coding}

Now that you've gone through the Getting Ready to Code chapters, we can turn our attention to the first portion of the Style Guide--Coding Style. 

## General Coding Style {#genCode}

Our Coding Style is based upon the [tidyverse style guide](https://style.tidyverse.org/). However, we do make some important departures and have some additional practicies that you will need to follow. 

When it comes to our Coding Style we strive to adhere to the following principles:

+ Make your code readable
+ Make your code efficient
+ Make your code readable
+ Be kind to future coders
+ Make your code readable

Yes, we realize that we stated "Make your code readable" three times. Readable code is the *__MOST__* important thing you can do. Even if you don't write the most efficient code, readable code will allow future students to examine your code and suggest improvements. Further, readable code will help you make sense of what *you* were trying to do when you come back to the app after several weeks or months. We will discuss all three of these principles in turn.

## Make Your Code Readable {#readable}

For us, making code readable boils down to three major aspects: formatting and spacing, naming, being explicit. By way of an example, consider the following code:

```{r badCodeExample1, echo=TRUE, eval=FALSE}
# Bad Code Example
selectInput("input1","pick",listA,NULL,TRUE,FALSE,"80%",2)
```

Just looking at this code, do you have any idea what it does? Let's look at a BOAST version of this code:

```{r goodCodeExample1, echo=TRUE, eval=FALSE}
# Good Code Example
selectInput(
  inputId = "selectedPeople",
  label = "Select who to contact",
  choices = nameList,
  selected = NULL,
  multiple = TRUE,
  selectize = FALSE,
  width = "80%",
  size = 2
)
```

While the above code takes more lines, it is infinitely more readable. Both sets of code call the same function, `selectInput`, to create a dropdown menu where the user can select individuals. In the Bad example, the user has to either 1) have the order of arguments memorized, or 2) guess what each argument does. In the Good example, each argument is listed out by name (e.g., `inputId` and `multiple`). While you might not know what each of these arguments controls (yet), you can at least see what values are being passed to each one. Further, you know that the choices are stored in the `nameList`, which is a much clearer name than `listA`. 

### Formatting and Spacing {#formatSpace}

One of the most important aspects of making code readable is through proper formatting and spacing. A common belief is that the fewer the lines of code, the better the program. However, what often happens when people attempt to follow this belief is that they wind up with indecipherable code...even to themselves. Thus, they violate not only our Readability principle but also our Be Kind principle. 

#### Line Length

With only a few exceptions (e.g., URLs), we want to keep each line to no more than 80 characters long. RStudio has a built in tool to help you with this.

1. Click on the Tools menu and select Global Options...
2. Click on Code in the left menu that appears
3. Along the top of the window for Code, find and click on Display
4. Check the box for Show margin and ensure that 80 appears in the box labeled Margin column.
5. Click Apply and OK.

This will add a thin grey line to the editor window that marks where the 80 character limit occurs. While this won't force you to a new line, this will serve as visual cue to you that your code line is too long and you should press return to move to a new line.

If you only have a few characters left, then finishing the line and making a line just a few characters over 80 is acceptable. Just try to keep such exceptions few and far between.

#### Indentation

Indenting your code is a great way to help with readability. RStudio will automatically do this for you. In the Good Example above, each of the arguments was indented 2 spaces; this helps convey that they are nested inside the object that was less indented. 

You can (and will) have nested indentation, for example:
```{r goodCodeExample2, echo=TRUE, eval=FALSE}
# Example of Indentation
ui <- list(
  dashboardPage(
    dashboardHeader(
      # code omitted
    ),
    dashboardSidebar(
      # code omitted
    ),
    dashboardBody(
      tabItems(
        tabItem(
          tabName = "overview",
          # code omitted
        )
      )
    )
  )
)
```

We have several layers of indentation but by looking at the formatting, we can see which things are at which level and their relative ranks. For example, the Header, Sidebar, and Body are all at the same level (i.e., they are all aligned at the same indentation), while they are all subordinate to the Page and the user interface ("ui"). The tab called "overview" is part of the Body based on the indentation.

One benefit of proper formatting through indentation is that you can get a quick visual check of proper close parentheses with the nice cascade or close/right parentheses. When parentheses are directly on top of one another or have gaps between then, that is a good sign that have not proper closed a section and could either encounter a fatal error (app crash) or display errors. RStudio 1.4 will bring Rainbow Parentheses to help you visually match up grouping symbols (parentheses, square brackets, curly braces, etc.)

RStudio should automatically indent code for you as you write and press the return/enter key. In the event that a line gets off, or you want to double check indentation, there is a keyboard shortcut that allows you to re-indent the line your cursor is in given the line just above: for Macs press Command + i; for Windows press Control + i. Keep in mind that this short cut works only on one line at a time and always references the one line just above the one you're in.

#### Function Calls

To format function calls, we will want to type the name of the function and the immediately put a open/left parenthesis--`functionName(`--what happens next depends on what you're trying to do:

+ If the function takes/needs no arguments, then immediately type the close/right parenthesis, e.g., `copyrightInfo()`, and return to a new line.
+ If you can fit all of the arguments on that line without going beyond 80 characters, the you can do so. For example, `renderIcon(icon = "correct")`.
+ In all other cases, press the return/enter key to move to a new line which should automatically indent. Enter each argument name and value followed by a comma on their own line. After you've typed the last argument's value, omit the comma, return to a new line and put the close/right parenthesis. For example,
```{r goodCodeExample3, echo=TRUE, eval=FALSE}
# renderIcon has three arguments: icon, width, and html
output$markProb1 <- renderIcon(
  icon = ifelse(
    test = input$probVal1 == answer1,
    yes = "correct"
    no = ifelse(
      test = abs(input$probVal1 - answer1) <= 0.05,
      yes = "partial",
      no = "incorrect"
    )
  ),
  width = 60,
  html = TRUE
)
```

If you've set up RStudio to automatically create pairs of grouping symbols, the close/right parentheses should automatically format themselves when you return to new lines.

#### Assignment Operator

To store a value, define a function, etc., you need to use the assignment operator `<-`. In the above examples, you'll notice that we used this operator to create the UI (`ui <- list()`) and to create the grading mark (`output$markProb1 <- renderIcon()`). These are both appropriate usages of assignment. You should not use `=` in these cases.

You'll also notice that we used `=` with all of the argument names and their values. This is proper usage. You need to pass values to arguments through the `=` sign and not `<-`.

#### Spacing

Spacing (or whitespace) refers to the portions of your line where you don't put any characters. In the bad example above, there was no whitespace in the code; everything ran together. Spacing acts in code exactly like it does in written languages. Whileapersoncanreadasentencewithnospaces, the sentence is much easier to read when we use proper spacing. 

+ Put a space on both sides of `<-`, and `=`
+ Put a space after every comma, unless the comma ends a line
+ Put a space after `if`, `else`, `else if`, and `for` (but not `ifelse`)
+ Put a space on both sides of comparison operator (e.g., `<`, `>=`, `!=`)
+ Put a space on both sides of mathematical operators (e.g., `+`, `*`, `^`, `%%`, `~`)
+ Put a space between the condition for an `if`/`for`/`else if` and the open/left curly brace `{`, then return to a new line.
+ When closing a chunk of code with a curly brace, `}`, if you are moving into an `else` or `else if` chunk, place a space after the close brace and then type `else`. For example, `} else {` or `} else if (condition) {`. Otherwise, return to new line.

### Use Informative Names {#naming}

Use informative names for variables and functions in your code. Use names that give another person a sense of what that variable represents (nouns) or what the function is supposed to do (action verbs). For example,

- `scoreMatrix` is a matrix that holds a set of scores  
- `checkGame` is a function that checks the state of the current game

Use [camelCase](https://en.wikipedia.org/wiki/Camel_case) for variable names and functions. The first word begins with a lowercase letter and additional words start with Capital letters with no spaces or underscores ( \_ ) between them. (This is a departure from the tidyverse style.)  

Avoid using the variable names from code that you're making use of from another app or script. For example, don't use `waitTimes` to hold your data on the number of correct answers a user has given. It is also good practice to avoid re-using function names that appear in other libraries that are currently loaded to avoid [namespace collision](https://en.wikipedia.org/wiki/Naming_collision).

### Be Explicit {#explicit}

One of the best practices a coder can do is to be explicit. And no, we don't mean that type of explicit. This links back to [Informative Naming](#naming) but goes a step beyond. `R` is a functional programming language. One of the important aspects of this is that functions in `R` obey the same rules as mathematical functions, especially multivariate functions. 

One implicit fact about functions that most students don't realize is that the order of a function's arguments are a matter of convention and is actually arbitrary. While we might define *f* as \(f(x,y) = x^2+3y\), we could call \(f(y=2,x=1)\) and get the same output as \(f(1,2)\) when we use the convention set up in the definition. This issue is exacerbated with functions in `R`.

Therefore, when you pass values to the arguments of a function in `R`, you should be explicit and include the argument name in your code. For example,

```{r explicit1, eval = FALSE}
bsButton(
  inputId = "submit",
  label = "Submit",
  color = "primary",
  style = "bordered",
  class = "btn-ttt"
)
```  

#### Why is being explicit important?

When you write explicit code, you not only improve your code's readability and are automatically being kind to future coders, but you're also guarding against certain forms of code breaking changes. When we build Shiny apps, we often call upon packages that other people have made. In those packages are functions that have a default ordering to them. For example, in one version of the package you might have `gradeThis(userInput, answerKey, partNumb)`, but in the newest version you have `gradeThis(partNumb, userInput, answerKey)`. If you were not explicit by naming the arguments in calls of `gradeThis` updating the package will cause your app to break and throw errors.

Further, being explicit also reduces the number of message printed to the console. For example, in `ggplot2`, if you call `geom_smooth(method = lm, se = false)` your code will execute properly. However, you will get a message in the console to the event that `geom_smooth` used `y ~ x`. You can suppress this message simply by adding `formula = y ~ x` to the `geom_smooth` argument list. (Anything that gets printed to the console fills up your app's log file. The more that's in the log file, the hard they are to use to debug your app if/when it crashes. Thus, we want to keep the console as quiet as possible.)

### Exceptions to Readability

There are few places where we make exceptions to the above formatting rules. These exceptions include the Dashboard Header and the Dashboard Sidebar. While we keep these lines readable, they follow a sightly different set of formatting to minimize their impact on the readability of the rest of the code. The App Template already has code in these sections for you to copy/paste for additional lines.

If you are ever unsure about how readable your code is, all you have to do is ask someone else. This is a great place for using Peer Reviews can help all students involved wither their coding skills.

## Make Your Code Efficient {#efficient}

### DRY Coding

### Minimize Package Usage {#minPackages}

Make sure that you absolutely have to use a particular package before you do. Check to see if what you're trying to do can be done in a package you're already using or in base R. 

A previous student loaded the `scales` to use the `percent` function to convert a decimal into a percentage. This is problematic for a couple reasons: the `percent` function has been depreciated (i.e., the developers do not wish people to use it any more and plan to get rid of it) and it is unnecessary. What the student could have done is write the following bit of code: `paste0(0.1 * 100, "%")`. If needed in several places, they could have written their own function:

```{r percentFunction, echo=TRUE, eval=FALSE}
makePercent <- function(proportion){
  return(paste0(proportion * 100, "%"))
}
```

This is not to say that you can't make use of a new package. This guideline's purpose is to streamline the various packages that get used in BOAST and to use the most of the packages that we are using. However, there are times when we just need to use a new package. Please try to use packages that are housed on CRAN and are preferably under active development. Searching GitHub for the package name can help you decide whether the package is active.

To help you avoid name masking (i.e., [Section \@ref(explicit)](#explicit)), ensure that you are actually using a package, and to help future readers follow your code, explicitly call packages with their functions. For example, use `dplyr::filter([arguments])` instead of just `filter([arguments])`. If you are using a common package and have no risk of name masking, you can dispense with this. For example, you can use `ggplot([arguments])` rather than `ggplot2::ggplot([arugments])`.

You can also run a `funchir::stale_package_check` on your `app.R` file to see which packages you're loading but might not actually use in your code. These stale packages may then be deleted out from your library call.

```{r staleCheck, echo=TRUE, eval=FALSE}
# Check working directory
getwd()
# Does the output match the folder path to where you app lives?
# If not, then you need to set that. For example,
setwd("~/Documents/GitHub/shiny-apps/Sample_App")

# Run a stale package check on app.R, ui.R, and server.R
funchir::stale_package_check("app.R")
```

Be aware that while `stale_package_check` is useful, it doesn't always catch everything. For example, when we ran it on the sample app, we were told that there were no exported functions from `ggplot2` or `tippy`. However, we know that there are functions from both of those. If you have a giant list of libraries to check, there might some more misses.

Once you're sure that a package isn't being used, remove the `library` call for that package from your code.

### Minimize External Files {#exFiles}

Try to minimize the number and size of external files you're attaching to your App. If you're working on an existing app, remove any external files that are no longer necessary.

Wherever possible try to place external files into the `www` directory/folder that is at the same level as your `app.R` or `ui.R`/`server.R` files.

If there are any external files (e.g., `*.csv`, `*.txt`, `*.dat`, `*.jpg`) that are not being used, delete them from the repository.

## Be Kind to Future Coders {#beKind}

Keep in mind that we have a high turnover with a new group of students each summer. Thus, we need to ensure that we go out of our way now to help those students out. Strive to write the quality of code you wish you would have wanted to start with. If you follow the Readability and Efficiency Principles, you'll be well on your way to being kind to future coders. The best way to go above and beyond is through comments.

### Leave Comments {#comments}

At bare minimum, use a comment to break your code into sections. This helps you and others conceptualize the code into more manageable chunks. Your comments can provide others with potential keywords to search for when looking at your code later on.

For particularly complex sections, use comments to summarize what you're trying to do. This can help you and others pick up the coding thread for what you are trying to do for troubleshooting, debugging, and future improvements.

Keep in mind that being kind is not only for other people, but also for yourself. When you come back to an app even after a couple days away, comments in addition to the readability and efficiency steps will help you see where you left off.
