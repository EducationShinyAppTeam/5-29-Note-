[
["index.html", "The BOAST Style Guide Welcome", " The BOAST Style Guide Neil Hatfield (njh5464@psu.edu) and Robert Carey (rpc5102@psu.edu) 28 May 2020 Welcome This guide spells out the styling that should be used for all apps included in the Book of Apps for Statistics Teaching (BOAST). Keep in mind that there are several different aspects to what makes up Style including: Coding (how you write, organize, and comment the code that makes the app) Visual Appearance (how you make the app look including tabs, fonts, colors, icons, etc.) Wording (how you write information, instructions, and other messages to the users) Documentation (how you provide references, including code and data sources, and give credit) By following this style guide you’ll ensure that any app you create will meet our standards. Additionally, we’ve included some information on Acessibility for our apps, checking how your App works on mobile devices, and some additoinal tools that can help you develop your App. "],
["getStarted.html", "Chapter 1 Getting Started 1.1 Getting Started Checklist 1.2 boastUtils Package 1.3 Sample App 1.4 Workflow 1.5 Testing Your App", " Chapter 1 Getting Started Before you get too far into the Style Guide, we would like for you to take a moment and ensure that you have the following tools at your disposal. 1.1 Getting Started Checklist Ensure that you have all of necessary accounts and if not, put in a request to Bob (rpc5102). DataCamp GitHub EducationShinyAppTeam BOAST in Microsoft Teams (tied to your PSU AccessID) Ensure that you have all of the proper software. R (version 3.5.* minimum, version 4.0.0 preferred) [Download] RStudio Desktop(most current version preferred) [Download] Additional Software that we recommend GitHub Desktop [Download] R Packages–here are some basic packages that everyone will need; be sure to install their dependencies too: install.packages(c(&quot;devtools&quot;, &quot;ggplot2&quot;, &quot;shiny&quot;, &quot;shinyBS&quot;, &quot;tidyverse&quot;)) A copy of the Sample App (see below) 1.2 boastUtils Package Bob created the boastUtils package to automate much of the design and development process. This will not only reduce the amount of work you’ll need to do, it’ll also make apps more consistent. Starting Summer 2020, you will be required to you make use of this tool. Please check out the package’s page for instructions on installing and usage. library(devtools) devtools::install_github(&quot;EducationShinyAppTeam/boastUtils&quot;) 1.3 Sample App Bob and Neil have created a Sample App repository that you can use as a template for your own apps. To get started, clone the Sample_App template repo found on GitHub. This will provide you with a skeleton for organizing your files as well as your code. There are several methods you can use: Direct Download (Basic) GitHub Desktop (Recommended) Command Line (Advanced) 1.3.1 Direct Download You can download this repository directly by visiting: https://github.com/EducationShinyAppTeam/Sample_App/archive/master.zip 1.3.2 GitHub Desktop If you are using GitHub Desktop and have linked your account that has access to the EducationShinyAppTeam repository, you can do the following from inside GitHub Desktop: Bring up the Clone Repository Menu (File -&gt; Clone Repository…) Enter Sample_App in the search bar and select the option that says Sample_App (not sampleapp) Click the Choose… button for the local path (this is where you want to the clone to live on your computer) Click the Clone button. See also: GitHub Desktop Help 1.3.3 Command Line Enter the following command in your terminal: git clone git@github.com:EducationShinyAppTeam/Sample_App.git See also: Git Handbook Resources to learn Git Happy Git and GitHub for the userR 1.4 Workflow As you work on apps, both updating existing and developing new ones, moving through a workflow can help you organize yourself. 1.4.1 Revising/Updating Existing Apps Read the Style Guide Explore the existing apps in the book When you identify an app you wish to work on, Go to that app’s repository in GitHub Create new issues on GitHub to log both bugs and suggestions for improvements Create an issue specifically if the App currently does not abide by this Style Guide Optional–assign yourself to the issue Download the current version of the app by using either RStudio or GitHub Desktop. Create a new branch for your developments. Begin editing the code As you edit, be sure to reference this Style Guide and test your code locally via Run App in RStudio. Periodically push your edits to your development branch. Don’t forget to add commit messages and reference any issues. When you’re ready to do larger scale testing you’ll need to publish your App to the TLT RStudio Connect server (See Section 1.5). When you’ve reached a point where you’ve finished editing, push your most recent commit to your development branch and then create a Pull Request. Assign Neil as a reviewer. Make any requested changes and re-push to your development branch. Update the Pull Request with a new comment. If everything checks out, then we’ll merge your development branch with the master branch and schedule formal deployment of your App. 1.4.2 Creating New Apps Read the Style Guide Identify a topic for your new App Sketch out your plans for the App. This should occur BEFORE you start coding. Be sure that you include: Suggested Title Goal of the app What will the user be doing (i.e., potential inputs) What will the user be experiencing (i.e., potential outputs) Relationships between various elements. When your plan gets approval, create a new repository on GitHub (See Section 2.5); you can initially load the Sample App template to this repository, if you wish. Begin writing the code As you edit, be sure to reference this Style Guide and test your code locally via Run App in RStudio. When you get the basic structure of your App set up, push your code to GitHub and create a new development branch for your continued editing. You can open new issues on your app as you go. Periodically push your edits to your development branch. Don’t forget to add commit messages and reference any issues. When you’re ready to do larger scale testing you’ll need to publish your App to the TLT RStudio Connect server (See Section 1.5). When you’ve reached a point where you’ve finished editing, push your most recent commit to your development branch and then create a Pull Request. Assign Neil as a reviewer. Make any requested changes and re-push to your development branch. Update the Pull Request with a new comment. If everything checks out, then we’ll merge your development branch with the master branch and schedule formal deployment of your App. 1.5 Testing Your App To test your App beyond your local machine, we will be making use of TLT’s RStudio Connect platform. You will need to following these directions. 1.5.1 Set Up/Login to the VPN Please refer to the following PSU Knowledge Basis Articles: VPN for Mac OS VPN for Windows VPN for Apple iOS VPN for Android You MUST be logged into the PSU VPN to both upload and test your App on each device. 1.5.2 Connecting Your RStudio to TLT’s RStudio Connect You only need to do this step once. After you’ve logged into the PSU VPN, go to TLT’s RStudio Connect and log in using your PSU ID. Once logged in, click on the Publish button Figure 1.1: Click the Publish Button Select Shiny App and a pop up window will appear. Follow the steps in this window (especially Step 4) to set up the connection. 1.5.2.1 Checking You’ve Connected You can check to see if you’ve connected by going into RStudio’s Options and looking at the Publishing tab. You should see a similar entry as what is in the green box below: Figure 1.2: Check Your Publishing Profile 1.5.3 Publishing Your App for Testing Make sure that you are connected to PSU’s VPN and that you’ve already connected your RStudio to TLT’s server. Click on the Publishing Icon, located just to the right of the Run App button. Be sure to select the TLT Server. 1.5.4 Configuring for Testing Once your App has been published, a new window should open in your browser that shows your App plus the optional controls. Figure 1.3: Successful Publish and Settings In Figure 1.3, you will need to change a setting to enable others (people and devices) to test your app. Click on the Access tab and set Who can view this application to Anyone-no login required. (These are highlighted in the green boxes.) Keep in mind that all users/devices MUST first connect to the PSU VPN to access your app. If you want, you can add collaborators as I did in the example (orange box). This is not required. The most important piece is the Content URL (marked with the blue star). You’ll need to copy this URL and give that URL out to your testers. This will allow them easily access your app, regardless of the type of device they are using. 1.5.5 Check the Logs As you test your App, you’ll want to look for any error messages and/or warnings that get generated. Click on the Logs tab (red box in Figure 1.3) to view. 1.5.6 Problems? If you run into problem either publishing your App or getting the App to launch on the TLT, please reach out to Neil and Bob. "],
["coding.html", "Chapter 2 Coding Style 2.1 General Coding Style 2.2 Organizing Code 2.3 Metadata 2.4 CSS 2.5 GitHub Repo Names 2.6 Using rlocker", " Chapter 2 Coding Style Now that you’ve gone through the Getting Started section, we can turn our attention to the first part of the Style Guide: Coding. There are many aspects that fall under the heading of Coding Style. 2.1 General Coding Style Our general practice is to make use of the tidyverse style guide. However, we do have some important departures and additional practices you need to follow: Leave comments Use informative names Format your code Be explicit 2.1.1 Leave Comments At bare minimum, use a comment to break your code into sections. This helps you and others conceptualize the code into more manageable chunks. Your comments can provide others with potential keywords to search for when looking at your code later on. For particularly complex sections, use comments to summarize what you’re trying to do. This can help you and others pick up the coding thread for what you are trying to do for troubleshooting, debugging, and future improvements. 2.1.2 Informative Names Use informative names for variables and functions in your code. Use names that give another person a sense of what that variable represents (nouns) or what the function is supposed to do (action verbs). For example, scoreMatrix is a matrix that holds a set of scores checkGame is a function that checks the state of the current game Use camelCase for variable names and functions. The first word begins with a lowercase letter and additional words start with Capital letters with no spaces or underscores ( _ ) between them. (This is a departure from the tidyverse style.) Avoid using the variable names from code that you’re making use of from another app or script. For example, don’t use waitTimes to hold your data on the number of correct answers a user has given. It is also good practice to avoid re-using function names that appear in other libraries that are currently loaded to avoid namespace collision. 2.1.3 Format Your Code See also 2.2 Organizing Code Use indentation spacing to help make your code readable. RStudio has a built-in tool that can help with this. Select all of the code you want to reformat. To select all code in a file, use Command-A (Mac) or Control-A (Windows). Press Command-Shift-A (Mac), Control-Shift-A (Windows), or click on the Code menu and select Reformat Code. NOTE: this tool is imperfect and can result in left parenthesis or curly braces moving up a line to where you might have an end-of-line comment, resulting in errors. Additionally, you can make use of the styler and lintr packages to help you perform formatting checks and to quickly reformat code. 2.1.4 Be Explicit One of the best practices a coder can do is to be explicit. And no, we don’t mean that type of explicit. This links back to Informative Naming but goes a step beyond. R is a functional programming language. One of the important aspects of this is that functions in R obey the same rules as mathematical functions, especially multivariate functions. One implicit fact about functions that most students don’t realize is that the order of a function’s arguments are a matter of convention and are actually arbitrary. While we might define f as \\(f(x,y) = x^2+3y\\), we could call \\(f(y=2,x=1)\\) and get the same output as \\(f(1,2)\\) when we use the convention set up in the definition. This issue is exacerbated with functions in R. Therefore, when you pass values to the arguments of a function in R, you should be explicit and include the argument name in your code. For example, actionButton( inputId = &quot;submit&quot;, label = &quot;Submit&quot;, color = &quot;primary&quot;, style = &quot;bordered&quot;, class = &quot;btn-ttt&quot; ) There are a few exceptions to this: Formula Arguments (e.g., response ~ factor1 + block) Data Vectors/Frames (e.g., dataFrame$response) Functions from shiny, shinydashboard, shinyBS, etc. E.g., you can call dashboardHeader rather than shinydashboard::dashboardHeader General Advice: If you are calling a function from a package that is unique to your App or not commonly used, list the package in the function call. If you are using a common/central function (i.e., those from shiny, ggplot2), you can omit the package in the function call. Remember the following: the more proactive you are from the get go in commenting and organizing your code, the easier time you will have for debugging and improving your code down the road. 2.1.5 HTML Our Shiny apps live on the internet and are thus going to be wrapped in HTML even though we are writing them in R. When you run a Shiny app, R and the shiny packages actually convert all of the R code into an HTML document which is served up to the user. While you will not have to directly write HTML for your apps, you should become aware of HTML tags that you will need to deal with when coding/writing your App. Further, you need to learn how to use these tags correctly as failure to do so becomes an Accessibility Issue. HTML Tags should not be used without some basic understanding of what that tag is for. Using the tags without such an understanding can not only lead to problems with your code running properly or looking like what you intended, but can interfere with how accessible your app is to wider audience. Here are the most common HTML tags that you’ll encounter when making a Shiny App. 2.1.5.1 Lists There are two aspects to lists: the items in the list and the environment those items live in. The two list environment are Ordered Lists and Unordered Lists. The Ordered List environment is for when you want require that user works through the items in a particular order. You call this environment in your App by using tags$ol( [your list] ). These lists are sequentially numbered/lettered. The Unordered List environment is for when you want to give the user a list where they can jump around between the items however they wish. You call this environment in your App by using tags$li( [your list] ). These lists will appear with bullets. Once you’ve created the list environment, you create items for your list in the same way: tags$li([content]). You do not need to and should NOT use any header or paragraph tags with your list items; our Style Sheet will take care of the formatting. You can use emphasis/italics or strong/boldface on portions of the content as appropriate. Here is an example of how you might create a list: tags$ul( tags$li(&quot;This is my first item.&quot;), tags$li(&quot;A second item with a&quot;, tags$strong(&quot;boldface&quot;), &quot;word.&quot;) ) which turns into This is my first item. A second item with a boldface word. There is one exception to the environment that you need to be aware of: the Dashboard Header has a built-in listing environment and thus you will jump straight to tags$li() when in that section. 2.1.5.2 Headers Heading tags provide a navigational structure to your app. Think of them as being the different levels of titles in a book. They are NOT for making text larger, boldface, or other text styling. Think about the headings as laying out a Table of Contents for your app, rather than containing content. There is a specific ordering to the Header tags that is critical to ensure your App is accessible by screen readers. h1() is for the Title of your App and should be ONCE at the top of the first page that appears when you load the app (i.e., the Overview). h2() is for Page titles within the App. These would correspond with the tab links you place in the dashboard’s left side panel. h3() is for titling Sections within a Page of the App. These might title the portion of the page that is for a game board, questions, answers, and graphs/plots. h4() is for a Subsection within a section. You might use this to distinguish different sets of controls in a Controls section. h5() and h6() should be used sparingly. These might be used for different levels of a game. When you call these in your App, you just call them as listed here; i.e., h1(), h2(), etc. Avoid skipping heading levels as this will get your App flagged for an Accessibility Violation. That is to say don’t start at h2 with no h1 and don’t go from h1 to h3 without an h2. Again, think of these as the layers of your table of contents or the outline of a paper; you wouldn’t skip whole sections in either of those. Here are few more things to NOT do with the heading tags: DO NOT USE headings to style text (We cannot stress this enough.) Do not wrap a header tag around a list element (e.g., h3(tags$li(\"here is my list item\"))) nor the reverse (e.g., tags$li(h3(\"here is my list item\"))) Do not mix header tags together in the same line or with the paragraph tag (e.g., `h2(“Introduction to”, p(“my game”))) For more information check out the W3C’s Tutorial 2.1.5.3 Paragraphs Your content should be enclosed in the paragraph tag, p(). Even if your content is relative brief or a mathematical expression, the paragraph tag will ensure that the content is sized correctly and readable. This tag tells screen readers and browsers what your content actually is. 2.1.6 Styling Text The styling of text (including font size, font weight (i.e., boldface), font family, color, etc.) is something that we began standardizing in Fall 2019. This is centrally managed by Neil and Bob to ensure 1) consistency across apps, 2) to cut down on the extraneous coding you need to do (this way you can focus on the apps), and 3) ensures that our apps are accessible and mobile friendly. To this end: The styling of text will be controlled using an external CSS (Cascading Style Sheet) file. You will implement this depending on what approach you use: If you’re using the boastApp function from boastUtils (recommended for all new apps), you don’t need to do anything as the appropriate calls will automatically be done for you. If you are using the ui.R and server.R format (i.e., apps from prior years), place the following code in the tags$head( ) portion at the top of the dashboardBody section of the ui.R file : dashboardPage( skin = &quot;blue&quot;, dashboardHeader( title = &quot;title&quot;, titleWidth = 300, # [omitted code] ), # [omitted code], dashboardBody( tags$head( tags$link(rel = &quot;stylesheet&quot;, type = &quot;text/css&quot;, href = &quot;https://educationshinyappteam.github.io/Style_Guide/theme/boast.css&quot;), tabItems( # [omitted code] ) ) ) ) There times when you might need some additional text styling that is not already defined. In these cases, you’ll need to talk to Neil or Bob to determine what is the best course of action. This could entail an addition to the central CSS file or the inclusion of an additional CSS file unique to your App. The central CSS file should only be altered by Neil or Bob and covers many aspects. However, this is a living file meaning that we will add to/alter the file as needed to improve the whole set of BOAST apps. See also the CSS section (2.4). 2.1.7 Minimize Package Usage Make sure that you absolutely have to use a particular package before you do. Check to see if what you’re trying to do can be done in a package you’re already using or in base R. This is not to say that you can’t make use of a new package. This guideline’s purpose is to help to streamline the various packages that get used in BOAST and to use the most of the packages that we are using. However, there are times when we just need to use a new package. Please try to use packages that are housed on CRAN and are preferably under active development. Searching GitHub for the package name can help you decide whether the package is active. To help you avoid name masking (i.e., Be Explicit-2.1.4), ensure that you are actually using a package, and to help future readers follow your code, explicitly call packages with their functions. For example, use dplyr::filter([arguments]) instead of just filter([arguments]). You can also run a funchir::stale_package_check on your app.R, ui.R, and sever.R files to see which packages you’re loading but might not actually use in your code. These stale packages may then be deleted out from your library call. 2.1.8 Minimize External Files Try to minimize the number and size of external files you’re attaching to your App. If you’re working on an existing app, remove any external files that are no longer necessary. Wherever possible try to place external files into the www directory/folder that is at the same level as your app.R or ui.R/server.R files. 2.1.9 Plot Caching There are cases when your app will include a plot that falls into any of the following categories: a plot that all users will see (i.e., static data set), is a computationally intense plot (i.e., lots of data and/or layers), might be a dynamic graph that the user explores and needs to move back and forth between various states. Each of these cases represents a place where the performance of your app can suffer. To improve performance, you should consider using the renderCachePlot function rather than renderPlot. This function will store a copy of each plot on the sever and provide that stored copy to new instances of the app. This cuts down on server demands and speeds up your app. For the third category, this allows the users to move more quickly to a previously examined state (i.e., low to no hang time). 2.2 Organizing Code There is a fixed order in which you should write your code. This will depend on if you are using a singular app.R file or the pair ui.r and server.r. 2.2.1 Using app.R The order for your code will be as follows: Packages to be loaded App Metadata (see below) Any additional source files UI definition Server definition boastApp call 2.2.2 Using ui.R and server.R The order for your code in the ui.R file: Packages to be loaded App Metadata (see below) Any additional source files UI definition The order for your code in the server.R file: Packages to be loaded Any additional source files Server definition 2.3 Metadata Your App will need the following metadata in either the app.R or the ui.R file. For long lines, use the paste function to allow you to break code lines apart but end up with a cohesive string for printing. This data is used to teach the Learning Management Systems (LMS) and Learning Record Stores (LRS) what your App does. More formats will be supported in the future. For now, use the following format: ## App Meta Data---------------------------------------------------------------- APP_TITLE &lt;&lt;- &quot;Title of the app&quot; APP_DESCP &lt;&lt;- paste( &quot;Description of the app&quot;, &quot;use multiple lines to keep the description legible.&quot; ) ## End App Meta Data------------------------------------------------------------ Notice that both APP_TITLE and APP_DESCP do not follow camelCase. This is by intent to denote global constants. 2.4 CSS Cascading Style Sheets (CSS) will be the way to control the visual appearance of all elements of the app. To ensure that we have consistent we will make use of the BOAST CSS throughout. This is relatively new (Winter 2019/Spring 2020), so many of the older apps will need to have this added to their code. This allows us to centralize and dynamically update all apps at once. There are a few key elements at play for CSS: All apps need to have the appropriate reference to the CSS file (See 2.1.6). Please register any issues, bugs, enhancements, new styling to the Style Guide repository of GitHub. Any App specific styling needs to as be in a CSS file and approved. There should not be any styling code in the app.R, ui.R, or server.R files (a.k.a. in-line CSS). Styling code would look like this: tags$style(HTML(\".js-irs-0 .irs-single, .js-irs-0 .irs-bar-edge, .js-irs-0 .irs-bar {background: orange}\")) style=\"color: #fff; background-color: #337ab7; border-color: #2e6da4\" For objects that need to have a particular styling invoked, we will make use of the class attribute. These will invoked through the HTML tags or through the function calls. # HTML Tag Example 1 p( class = &quot;hangingindent&quot;, &quot;Attali, D. and Edwards, T. (2018). shinyalert: Easily create pretty popup messages (modals) in &#39;Shiny&#39;. (v1.0). [R package]. Available from https://CRAN.R-project.org/package=shinyalert&quot; ) # HTML Tag Example 2 div(class = &quot;updated&quot;, &quot;Last Update: 12/2/2019 by NJH.&quot;) # Function Call Example actionButton( inputId = paste0(&quot;grid-&quot;, row, &quot;-&quot;, column), label = &quot;?&quot;, color = &quot;primary&quot;, style = &quot;bordered&quot;, class = &quot;grid-fill&quot; ) There is an exception to #3: setting up alignment for a div section. This would look like div(style = \"text-align: center\"...) This type of styling is allowed in the R files (generally in the UI portions only). If you come across an app that has in-line CSS OR calls to a CSS file that isn’t boast.css, please log an issue and mention/assign Neil. (Most common external CSS files are style.css and Feature(s).css.) 2.5 GitHub Repo Names Each Shiny App has its own repository (repo) on GitHub. As you begin to create new apps, you’ll have to create a new repo on GitHub for each one. The name of that repo is extremely important as this will play a critical role in establishing the URL for your App. To this end, you need to adhere to following guidelines: Use Title Case (not camelCase) Use underscores ( _ ) instead of spaces Match the App name as closely as possible You have a 100 character limit While we can change repo names, doing so results in a large number of edits that have to be made. Thus, think carefully about how you are going to name your repository. If you come across a repo that is poorly named, please make an issue and provide some suggestions for new names. 2.6 Using rlocker Because these apps are being developed for educational purposes, it is beneficial to collect data (logfiles) based on learning objectives and outcomes. The rlocker package was created to aid in this process. It is important to know that the package itself does not perform feats of magic and will require some tuning to get right. 2.6.1 Installing library(devtools) devtools::install_github(&quot;rpc5102/rlocker&quot;) View Documentation 2.6.2 Setup Core configuration is included in the boastUtils package. Simply use the boastApp wrapper function instead of shinyApp and you’re done! 2.6.3 Usage The main purpose of this package is to help create meaningful- structured- xAPI data. xAPI (Experience API) can be thought of as the “Who did what, where did they do it, and when did they do it?” in your App. Statements are often structured as Actor, Verb, and Object that sometimes also have a Result. For more on xAPI, check out What is the Experience API? or experiment with Statements in the xAPI Lab. For example: Bob (Actor) clicked (Verb) submit (Object). In assessments: Neil (Actor) answered (Verb) Question 1 (Object) correctly with the answer true (Result). This is a good way to frame it in your mind when beginning to write collection functions. Which brings us to our next part, writing collection functions. Out of the box, rlocker does not provide any collection functions for apps, only creation and storage mechanisms. Why is this? Every app is different! You know your app the best and what interactions are possible. Before storing data in a Learning Record Store (LRS) like Learning Locker, it is important to transform it in a way that makes sense. Sample generator function .generateStatement &lt;- function(session, verb = NA, object = NA, description = NA, interactionType = NA, response = NA, success = NA, completion = FALSE) { statement &lt;- rlocker::createStatement(list( verb = verb, object = list( id = paste0(getCurrentAddress(session), &quot;#&quot;, object), name = paste0(APP_TITLE), description = paste0(&quot;Question &quot;, activeQuestion, &quot;: &quot;, description), interactionType = interactionType ), result = list( success = success, response = response, completion = completion ) )) return(rlocker::store(session, statement)) } Sample event observer observeEvent(session$input[[id]], { # # # # Check app state + validation data; yours will be different! answer &lt;- gameSet[id, &quot;answer&quot;] description &lt;- gameSet[id,]$question interactionType &lt;- ifelse(gameSet[id,]$format == &quot;numeric&quot;, &quot;numeric&quot;, &quot;choice&quot;) success &lt;- input$ans == answer completion &lt;- ifelse(.appState == &quot;continue&quot;, FALSE, TRUE) # # # .generateStatement( session, object = id, verb = &quot;answered&quot;, description = description, response = input$ans, interactionType = interactionType, success = success, completion = completion ) } Additional code can be found in the examples folder as well as the main README of the project; apps such as the Hypothesis_Testing_Game have been outfitted with rlocker. The statement generator above will eventually make its way into boastUtils once enough feedback is collected. If you are ever confused about how it works, feel free to reach out to Bob (rpc5102). Did you know? You can run help(package = \"rlocker\") to view the help files for this package or press F1 while typing a function name to see the documentation for that specific function. "],
["visualAppearance.html", "Chapter 3 Visual Appearance 3.1 PSU Branding 3.2 Dashboard 3.3 Common Elements 3.4 Colors 3.5 Text Styling 3.6 Graphics 3.7 Miscellaneous", " Chapter 3 Visual Appearance This chapter of the BOAST Style Guide deals with the Visual Appearance of each app. Visual Styling encompasses not only text styling but also color scheme usage, graphics (images, plots, tables), and the dashboard layout. For each app, there are 6 major components to the Visual Appearance that you will need to consider: PSU Branding, the Dashboard, Common Elements, Color, Text Styling, and Graphics. One of the most important benefits of using the boastApp function from the boastUtils package is that is that much of the Visual Appearance will be automatically handled for you. However, you should still familiarize yourself with the Visual Appearance Style for our apps. 3.1 PSU Branding Given that we are all associated with Pennsylvania State University, we need to include the Penn State logo in each App. Rather than sticking the logo at the top of the Overview page, we are going to place the logo at the bottom of the sidebar. This has the benefit of having the logo appear throughout the entire App AND making the logo be as unobtrusive as possible. In your UI section of app.R (or the ui.R file), at the end of the dashboardSidebar() section, you will need to include the following: tags$div(class = &quot;sidebar-logo&quot;, boastUtils::psu_eberly_logo(&quot;reversed&quot;)) Here’s how this code would look in context: dashboardPage( skin = &quot;blue&quot;, dashboardHeader( title = &quot;title&quot;, # [omitted code] ), dashboardSidebar( width = 300, sidebarMenu( id = &quot;tabs&quot;, # [omitted code], tags$div( class = &quot;sidebar-logo&quot;, boastUtils::psu_eberly_logo(&quot;reversed&quot;) ) ), dashboardBody( tags$head( tags$link(rel = &quot;stylesheet&quot;, type = &quot;text/css&quot;, href = &quot;https://educationshinyappteam.github.io/Style_Guide/theme/boast.css&quot;), tabItems( # [omitted code] ) ) ) ) ) This will ensure that the Penn State logo gets properly used. 3.2 Dashboard All apps will make use of a Dashboard structure. This divides the visual appearance of each App into three main areas. Across the top of the App will be the Header Along the left side of the App will be the navigation list (the Sidebar) where the various Tabs (pages) of your App will be listed The last area is the Body; this is where all content will appear 3.2.1 Dashboard Header Each Dashboard Header contains only a couple of elements. The most important of these will be a [shortened] Title of your App. This will automatically be followed by the sidebar collapse/expand button. At the far right, you will then include a link to the home page of BOAST using the Home icon. Additional icons might be included to the left of the Home icon. However, these icons remain the same for all Tabs/pages of your App and are thus are not appropriate for Tab/page specific information. There should not be any additional elements in the Dashboard Header. Any links for navigate in your App should appear in the Sidebar on the left edge. The width of the Title component of the Header should be 300; titleWidth = 300. 3.2.2 Sidebar and Body The Sidebar (responsible for App navigation) and the Body are intimately related to one another. The Sidebar provides structure to your App as well as being the primary way that a user can move around the App. The Body is where all content (text, images, plots, buttons, etc.) exists for the user to read, view, and interact with. The Sidebar should have a width of 300, (width = 300). To ensure a consistent experience across all apps, you need to make sure that your App has the following tabs/page, in the following order: 3.2.2.1 The Overview Tab This Tab is REQUIRED for all Apps. This is the main landing page of your App and should appear at the top of the sidepanel. The icon for this Tab must be “dashboard”. The Overview Tab must contain ALL of the following elements: “Title” (as Heading 1) A description of the app (as paragraph text under the title) “Instructions” (as Heading 2) General instructions for using the App (using an Ordered List environment) A button that will take the user to the next Tab/page. “Acknowledgements” (as Heading 2) A listing of acknowledgements including, coders, content writers, etc. (as a paragraph) Last Element: div(class = \"updated\", \"Last Update: mm/dd/yyyy by FL.\") with mm/dd/yyyy replaced with the date of the update you pushed to the server and FL replaced with your initials. There is no need to use boldface or colons with the section headings when you properly use Heading tags. Thus, “Instructions:” does not follow this Style Guide. Additionally, there should not be an “About” heading. 3.2.2.2 A Prerequisites Tab If your App needs to ensure that the user has the base understandings necessary to interact with your App, you’ll need to create a prerequisites Tab. Otherwise, skip this Tab. The icon for this Tab must be “book”. Use the word “Prerequisites” rather than “Pre-reqs”, “Prereqs”, or “Pre-requisites”. Keep in mind that there are two different types of prerequisites: technical/conceptual and contextual. Both of these go into the Prerequisites tab. Technical/Conceptual Prerequisites cover ideas that the user needs in order to fully engage with your App’s statistical goal. For instance, if your App is about ANCOVA, the ideas of ANOVA and building a linear model would be good candidates for technical/conceptual prerequisites. Contextual Prerequisites cover ideas that which are beneficial for the user to understand a context you’re using. For example, if you are referencing an astragalus, you should include a brief explanation and/or picture of an astragalus. Keep in mind that Contextual Prerequisites are different than context which should be part of the Activity Tab. If the information is necessary to interpret sliders/graphs and is specific, then you should include this information in the Activity Tab. If the information helps the user say “Oh, that’s what they mean by [blank]”, that is good sign of something to put in the Prerequisites Tab. 3.2.2.3 Activity Tab(s) This is the heart of your App and you are required to have at least one. In the event you have multiple activities, each one will need a separate Tab. The order of these Tabs will depend upon the your goals for the App. Each Tab should contain all information/instructions for the user to be able to interact with the activity without having to switch to other Tabs. The icon you use depends on the type of activity: Games will use the icon “gamepad”. Explorations will use the icon “wpexplorer”. Challenges will use the icon “gears”. 3.2.2.3.1 General Layout for Activity Tabs For the vast majority of Activity Tabs, we will adopt a 3-part layout: Across the top will be any general information the user needs to interact with your App as well as an context information. To the left and wrapped in a well panel will be the inputs/controls that the user will need to manipulate. To the right and NOT in a well panel will be the outputs (graphs, images, R output) There will be some cases where this general layout does not necessarily work. For instance, Tic-Tac-Toe games will not follow this layout. 3.2.2.4 References The last Tab will be for your references. This Tab is REQUIRED and is where you will place a reference list for all of the following items that you used in your app: All R packages you used Sources of any Code you used directly or drew heavily upon from other people Pictures and/or other images Data sets Refer to the Documentation Section (5) of this Style Guide for more information. The icon for this Tab must be “leanpub”. 3.2.2.5 Last Element The last element of the Sidebar will be the Penn State Logo. Please refer to the Section 3.1. 3.2.3 Tabs Inside the Body There are two types of tabs in a Shiny app: there are the tabItem (i.e., the pages within an app and should appear in the Sidebar) and tabPanel (i.e., creating sub-pages or independent sections). In this section, we will discuss this later case. Deciding on whether to use tabPanel is going to depend on several things: Do you have two or more aspects that are related enough that they shouldn’t be their own separate tabs/pages of your App? If NO, then you shouldn’t use tabPanel. If YES, then continue. Are any of your aspects something that would be better suited as a Challenge or Game tab? If YES, move that aspect to a separate page. If you still have 2+ aspects, continue. If NO, continue. Are the aspects independent enough that a person can skip a couple and still use the App successfully? If NO, then you should re-consider your design. If YES, then proceed with using tabPanel in you design. When you go to make a set of tab panels you will need to first create a tabsetPanel which will wrap around all of the individual panels. Use type = \"tabs\". The tabs inside the body should automatically appear horizontally and along the top of the tab body (i.e., in the white space below the Dashboard Header). Any visual styling will be managed by the BOAST CSS file at a global level. 3.3 Common Elements In addition to the Dashboard elements of the apps, there are other elements that are common. This include things such as how inputs should be ordered, buttons, correct/incorrect indicators, and animation buttons. For information about popovers, rollovers, hover text, or tooltips, please see Section 4.2. 3.3.1 Ordering Inputs One of the most powerful aspects of Shiny apps is that the user interacts with them. Thus, we do need to consider not only the ways in which user interact (e.g., buttons, sliders, text entry, etc.) but also the order in which you want the user to manipulate the inputs. Coming up with a single declaration for how to order inputs in all cases is not necessarily feasible. However, we can set up a general guideline for how to make decisions on ordering your inputs. Please use the following guidelines for determining the order of inputs in the User Interface (UI): In general, if you want your user to do things in certain order, make your inputs appear in that order. For example, If you want them to pick a data set, then an unusualness threshold/significance level, what attribute to test, and then set a parameter value, then your inputs should appear in that order. Make use of how we read the English language, i.e., Top-to-Bottom and Left-to-Right to provide an implicit ordering for your user. If a user needs to carry out steps in particular sequence for your App to run properly, then place your inputs inside of an Ordered List environment with explicit text on what they should do. For example, Choose your data set: [dropdown] Set your unusualness threshold/significance level [slider] Which attribute do you want to test: [dropdown] What parameter value do you want to use: [numeric input] If an input is going to reset other inputs you should either: Warn the user before hand Move the input to the top of the list Program the input to not reset other inputs Some combination of the above If the inputs are not dynamically linked to the output (e.g., plots automatically update with a change in the input’s value), then you should include a button that says “Make Plot” at the end of the inputs. 3.3.2 Buttons Buttons are one way in which users interact with the apps. The two most common functions that are used are shiny::actionButton and shinyBS::bsButton. Both functions share many of the same features. Two ways in which they are different is that shinyBS::bsButton has an additional style argument while shiny::actionButton has a width argument that gives you fine grain size control (bsButton just has a qualitative size option). There are three key styling aspects: shape/animation, color, and text &amp; icon. 3.3.2.1 Shape/Animation All shape aspects of buttons will be controlled by CSS. The standard shape will be rectangular (the default). Sizing will be controlled by CSS although setting size = \"large\" for the bsButton call may be done. We have a number of apps where a button will change shape/size when a person hovers their cursor over it. This “animation” is to be discontinued. This is to say that buttons which change shape/size should be flagged as issues and resolved at the first opportunity. At most, the button’s color might change (e.g., lighten or darken), depending on the context. 3.3.2.2 Color The coloring of the button will also be controlled by CSS in one of two ways. The default way will be through the BOAST CSS. This will ensure that the selected color scheme for your App will be consistent. The second way only applies to bsButton and the style argument. Here, this option references an external CSS file beyond BOAST. We see these most often in games. Use the following list to guide you in choosing which style: warning: Good for when you want the user to proceed with caution; for example a submit button in a game. danger: Good for when you want the user to think twice before clicking; for example, a reset game button. success: Good for when you want to convey that the user can proceed safely; for example, a button that advances the user through the game info: Good for when you want to give some additional information; for example, a button that triggers game instructions popping up, a button that gives a hint, or a button that might filter a question pool. When in doubt, use the the default style option (or even omit this argument) for bsButton or use actionButton. 3.3.2.3 Text &amp; Icon The last styling element of a button is two-fold: the text that is in the button and the icon. Here are some guidelines for text of a button: All buttons must have some text. Generally speaking, the text should be relatively brief and clear. Don’t use “Go to the next page” when you could use “Next” The text should make sense with the action of the button; for example, “Reset” if the button resets something (a game, a plot, inputs) “Submit” if the button triggers the app to grab and process input values “Make Graph” if button causes a graph to be generated “Show/Hide Graph” if a button makes a graph object appear/disappear “Next” if a button moves the user along some path. If the button references something like a particular tab (prerequisites, exploration, etc.), the text should reflect this. “Explore!” for a button that takes a user to an Exploration tab. “Prerequisites” for a button that takes a user to a Prerequisites tab. “Challenge Yourself!” for a button takes a user to a Challenge tab. “Play!” for a button that takes a user to Game tab. If a button references an object like an activity packet or a download prompt the text should refer to that “Activity Packet” for a button that would open up and/or download a packet for the user “Download Data” for a button that would download a data file. Clarity is essential. If there are multiple buttons on the page, make sure that you use clear text for what button does and/or references. Here are guidelines for the inclusion of icons in a button: Game buttons will NOT have any icons. Direction Buttons (e.g., “Next” or “Previous”) will NOT have any icons. Rather make the button text “&lt;&lt; Previous” or “Next &gt;&gt;” A “Prerequisites” button will use the “book” icon All other tab buttons (labels ending with “!”) will use the “bolt” icon. A download button will use the “cloud-download” icon. 3.3.3 Correct/Incorrect Marks In games, you can give the user a visual cue as to whether they are correct or incorrect through the use of two images: Figure 3.1: Correct/Incorrect Marks You can save these two images by right-clicking on them and selecting “Save Image As…”. You will need to put them in the www folder/directory of your App. Their placement in your App will depend upon what makes the most sense. 3.3.4 Animation Buttons One feature of slider inputs is the option to include a Play/Pause button that allows the user to create an animation of your plot. Enabling this option can be quite useful if allowing the user to move through the whole set of slider values is desirable. To enable this, you’ll need to make use of the animate argument: #[code omitted] sliderInput( inputId = &quot;mtcAlpha&quot;, label = &quot;Set your threshold level, \\\\(\\\\alpha_{UT}\\\\):&quot;, min = 0.01, max = 0.25, value = 0.1, step = 0.01, animate = animationOptions( interval = 1000, loop = TRUE)) #[code omitted] You can set animate=TRUE, animate=FALSE or invoke the animationOptions function as we’ve done in the example and recommend. This will force you to make some important decisions: namely, how long the slider should wait between each movement (interval, in milliseconds) and should the animation start over once the slider reaches the maximum (loop). The interval is going to the most challenging value to figure out. This timer ignores everything else; that is, it doesn’t wait to see whether your plot has updated. Remember, the more complicated the process is that generates your plot, the longer your App will need to render the plot. Thus, you can quickly get into a case where the slider has advanced several times while your App is still trying to render the first update. While renderCachePlot can help speed things up, keep in mind that you still might need to play around with the interval value to ensure smooth functionality. Make sure when you’re testing an animated slider to vary all of the parameters involved in the graph. This will help ensure that you test adequately. The styling of the play/pause button will be controlled by the BOAST CSS file. 3.4 Colors Your App needs to have a consistent color scheme throughout. The color scheme should be checked against colorblindness to meet WCAG 2.1 Level AA. You can do so at the Coloring for Colorblindness website. If you are following this Style Guide (as you should be) then the vast majority of this section will be automatically handled for you. There are two major places where coloring comes into play: the user interface and plots you generate in R. 3.4.1 Color in the User Interface Within BOAST, we use color themes to help provide consistency for the elements of each app and to denote different chapters. Part of the standardization process with the Style Guide seeks to bring the many fractured color themes together into a cohesive, centrally managed set. This helps reduce the programming burden from the students, who should focus on the R side of the programming, not the CSS side. All aspects of color in the User Interface should be controlled through the CSS file(s). This includes all of the following: Dashboard coloring (Header, Sidepanel, Body) Text coloring Coloring of Controls (including buttons, sliders, and other input fields) By using CSS, especially through boastApp, you’ll be able to ensure that there is consistent coloring throughout your App. 3.4.1.1 Implementing a Color Theme To activate a color theme is a simple process, especially if you are following this Style Guide and using the boastUtils package. (If you are in an App using ui.R and server.R, make sure that the boast.css call is in the ui.R file.) In your App’s code, go to where you first call the function dashboardPage. Then, as the first argument you’ll type skin = \"[theme]\" before moving on the next argument, dashboardHeader. You will replace [theme] with one of the following: blue, green, purple, yellow, red or black. The choice will be determined by the color assigned to that chapter. This is all you have to do. If you are unsure what color to put, use blue as the default. 3.4.1.2 The Themes There are six color themes that we’ve currently made. The names of the themes are a general indication of coloring, with one exception. The black theme is not black but rather an aqua/teal set. The themes are typically three colors (four for blue) and based upon the Penn State Palettes. Non-Penn State colors will be denoted with asterisks. All of the themes have been checked against 8 different forms of color blindness. 3.4.1.2.1 Blue The Blue Palette is our central palette and should be used by default. The Blue Palette looks like the following: Figure 3.2: The Blue Palette Here is what the Blue Palette looks like in action: Figure 3.3: Overview Page Using the Blue Palette Figure 3.4: Collapsible Boxes Using the Blue Palette Figure 3.5: Sliders Using the Blue Palette 3.4.1.2.2 Green The Green Palette looks like the following: Figure 3.6: The Green Palette Here is what the Green Palette looks like in action: Figure 3.7: Overview Page Using the Green Palette Figure 3.8: Collapsible Boxes Using the Green Palette Figure 3.9: Sliders Using the Green Palette 3.4.1.2.3 Purple The Purple Palette looks like the following: Figure 3.10: The Purple Palette Here is what the Purple Palette looks like in action: Figure 3.11: Overview Page Using the Purple Palette Figure 3.12: Collapsible Boxes Using the Purple Palette Figure 3.13: Sliders Using the Purple Palette 3.4.1.2.4 Black The “Black” Palette is not pegged to the color black, but rather teal/aqua colors. However, to call the theme in the Shiny dashboard, the user must use the value black for the the skin argument. Here’s what the “Black” Palette looks like: Figure 3.14: The ‘Black’ Palette Here is what the “Black” Palette looks like in action: Figure 3.15: Overview Page Using the ‘Black’ Palette Figure 3.16: Collapsible Boxes Using the ‘Black’ Palette Figure 3.17: Sliders Using the ‘Black’ Palette 3.4.1.2.5 Yellow The Yellow Palette is still under consideration. The current set looks like the following: Figure 3.18: The Yellow Palette Here is what the Yellow Palette looks like in action: Figure 3.19: Overview Page Using the Yellow Palette Figure 3.20: Collapsible Boxes Using the Yellow Palette Figure 3.21: Sliders Using the Yellow Palette 3.4.1.2.6 Red The Red Palette is still under construction. Here’s the current set: Figure 3.22: The Red Palette Here is what the Red Palette looks like in action: Figure 3.23: Overview Page Using the Red Palette Figure 3.24: Collapsible Boxes Using the Red Palette Figure 3.25: Sliders Using the Red Palette 3.4.1.3 Current Chapter Color Assignments Here are the current (05/27/2020) color theme assignments for chapters: Chapter 1: Data Gathering RED Chapter 2: Data Description YELLOW Chapter 3: Basic Probability BLUE Chapter 4: Statistical Inference PURPLE Chapter 5: Probability BLUE Chapter 6: Regression “BLACK” Chapter 7: ANOVA “BLACK” Chapter 8: Time Series PURPLE Chapter 9: Sampling RED Chapter 10: Categorical Data YELLOW Chapter 11: Data Science GREEN Chapter 12: Stochastic Processes BLUE Chapter 13: Biology GREEN 3.4.2 Color and Plots in R In R you can set color theme which you use in ggplot2. Here are two custom color palettes that you can use in your App. Additionally, the package viridis provides several additional color palettes which are improvements upon the default color scheme. # boastPalette is based on the Wong color blind set found at the above website. boastPalette &lt;- c(&quot;#0072B2&quot;,&quot;#D55E00&quot;,&quot;#009E73&quot;,&quot;#CE77A8&quot;, &quot;#000000&quot;,&quot;#E69F00&quot;,&quot;#999999&quot;,&quot;#56B4E9&quot;,&quot;#CC79A7&quot;) # psuPalette is based on Penn State&#39;s three official color palettes # and checked at the above webite. psuPalette &lt;- c(&quot;#1E407C&quot;,&quot;#BC204B&quot;,&quot;#3EA39E&quot;,&quot;#E98300&quot;, &quot;#999999&quot;,&quot;#AC8DCE&quot;,&quot;#F2665E&quot;,&quot;#99CC00&quot;) # Both palettes get used in the order of what is listed. To use these palettes (or ones from viridis) with a ggplot2 object, you’ll need to doe the following # You will need to first add whichever palette line from above to your code boastPalette &lt;- c(&quot;#0072B2&quot;,&quot;#D55E00&quot;,&quot;#009E73&quot;,&quot;#CE77A8&quot;, &quot;#000000&quot;,&quot;#E69F00&quot;,&quot;#999999&quot;,&quot;#56B4E9&quot;,&quot;#CC79A7&quot;) # Create ggplot2 object g1 &lt;- ggplot2::ggplot(data = df, aes(x = x, y = y, color = grp, fill = grp)) # Add your layers g1 + ggplot2::geom_points() # Tell R to use your chosen palette g1 + ggplot2::scale_color_manual(values=boastPalette) # If you use &quot;color&quot; in aes g1 + ggplot2::scale_fill_manual(values=boastPalette) # If you use &quot;fill&quot; in aes If you have more groups than eight/nine colors listed in the two palettes, consider reworking your examples as you could overwhelm the user with too many colors. (This also applies to using different shapes to plot points.) With any eye towards accessibility, try not to use only color to denote a particular piece of information. Rather you might want to use color and shape. 3.5 Text Styling Text styling refers the non-content aspects of the text on the page. This means things such as the use of italics, boldface, alignment, as well as font size and color. You should let the centralized CSS file do the heavy lifting for text styling. (Again, using boastApp will help you.) However, for this to work properly, you will need to tag content appropriately. (See the HTML section: 2.1.5) If you run into a situation where some element needs additionl styling, talk to Neil or Bob for help. You might have come across an element that needs to get added the central CSS file or a bug. 3.5.1 Headings Use the Heading Tags for the short fragments that define the structure of your App. If you find yourself enclosing a complete sentence in Heading tag, you ARE NOT using headings correctly. Notice how the headings in this Style Guide aren’t complete sentences; your App should mimic this. Full sentences appear as regular paragraph text (i.e., enclosed in p()) and not be a Heading. 3.5.2 Paragraph Text If you enclose text that gives instructions or other information to your App’s users in p() or li() (the later should be wrapped in either tags$ol() or tags$ul()), your App will understand how to style that text correctly. The central CSS file contains controls that set the base font size much larger than Shiny does natively as well as making text sizing dynamic. (This is important for making our apps mobile device friendly.) Again, using boastApp makes this process easier. If you want to make a certain word or phrase italic, you will need to wrap that text in tags$em(). Similarly, if you want do the same with boldface, you’ll use tags$strong(). For example, this code: p( &quot;When dealing with the &quot;, tags$em(&quot;t&quot;), &quot;-distribution, we only have one parameter, the &quot;, tags$strong(&quot;degrees of freedom&quot;), &quot;that we need to input.&quot; ) Becomes: When dealing with the t-distribution, we only have one parameter, the degrees of freedom that we need to input. Use italics (emphasis), and boldface (strong) sparingly. 3.5.3 Mathematics For the most part, any mathematics you need displayed should be done using MathJax. Default to using inline typesetting with the \\\\( and \\\\) delimiters. If you need to use display style, you can use \\\\[ and \\\\]. For the vast majority of mathematics, you’ll wrap both inline and display style mathematics inside of a paragraph environment (p()). If you’re writing mathematics directly in your app, remember you’ll need to escape the LaTeX commands by putting an extra backslash (\\) in front; e.g., \\frac{3}{4} would need to be \\\\frac{3}{4}. If you’re reading in mathematical text from an external CSV file, you do not need the extra backslash in the CSV file. If you need assistance in figuring out how to type up mathematics, please talk to Neil, Matt, or Dennis. Note: Double dollar sign delimiters are generally not recommended for displaying math as they can lead to unintended results. See: Writing Mathematics for MathJax. 3.5.4 [Game] Question Text The text used as a question in a game should NOT be wrapped in a Heading tag; wrap the text in a paragraph tag. 3.5.5 Label Text (Buttons, Sliders, Other Inputs and Alerts) By using the central CSS file, any text you included in/on buttons, dropdown menus, sliders, radio buttons, choices, and other inputs as well as alert messages and popups/rollovers, will automatically be styled correctly. Do not use heading tags, the paragraph tag, italics/emphasis, or boldface/strong with input labels. You may use these tags with popups/rollovers. 3.5.6 Feedback and Hint Text Again, let the central CSS file handle the styling of this type of text. 3.5.7 Text in R Plots Unfortunately, any text in R plots does not get controlled by CSS. This means that you’ll have to play around with the settings. Using the ggplot2 package to make your plots (or other packages based upon the ggplot framework) will allow you to use the theme aspect to control text in your App. Here is an example for how to do this: # Create a ggplot2 object g1 &lt;- ggplot2::ggplot(data=df, aes(x=x, y=y, color=grp)) # Add your layers, for example g1 + ggplot2::geom_point() # Use theme to control text size g1 + ggplot2::theme( plot.caption = element_text(size = 18), text = element_text(size = 18) ) You will need to play around with the settings to find the appropriate value; text size 18 appears to work out well in many cases. Note: The text in your plot might not behave well for dynamic resizing on different mobile devices. 3.6 Graphics One of the most powerful tools we have in Statistics and Data Science is graphics. This includes images/pictures, graphs/plots, and tables. You will want to make sure that all graphical elements are appropriately sized in the Body. If there is text in a static image/picture, you’ll need to make sure that the text is legible on a variety of screen sizes. We’ve already discussed both issues of color and text size in plots. For additional considerations, please refer to the following readings (ordered from most important to least): Tufte-Fundamental Principles of Analytical Design Tufte-Chartjunk Kosslyn-Looking with the Eye and Mind Remember, we always want to be modeling excellent graphing behaviors. All photographs can be fortified with words. –Dorothea Lange A picture is worth a thousand words…but which ones. –Unknown Both of these quotations highlight that you need to include some text with your plots to help the user construct their understanding of what you’re trying to show them. 3.6.1 Axes and Scales R’s default axes are terrible. They often do not fully cover the data and the have gaps between the axes. All this impedes the user’s construction of meaning. Thus, you’ll want to take control and stipulate the axes and scales to optimize what users get out of the plot. If you are providing multiple plots that the user is supposed to compare, make sure that they all use the same scaling and axes. To force ggplot2 to place (0, 0) in the lower-left corner and to control the scales, you will need to include the following: # Create the ggplot2 object g1 &lt;- ggplot2::ggplot(...) # Add your layer g1 + ggplot2::geom_point() # Control axes and scale ## Multplicative Scaling of the Horizontal (x) Axis ## Additive Scaling of the Vertical (y) Axis g1 + ggplot2::scale_x_continuous(expand = expansion(mult = c(1,2), add = 0)) + scale_y_continuous(expand = expansion(mult = 0, add = c(0,0.05))) 3.6.2 Tables Use tables as infrequently as possible. If you absolutely must include a table, you will need to decide what the role of your table is. This is an Accessibility issue that you MUST pre-plan for. Screen readers will poorly communicate tables if you fail to set the role appropriately. Talk to Neil and Bob before using a table. 3.6.3 Static Images Static image refers to any image you’re using in your App which is not produced by R. These are usually PNG or JPG/JPEG files which you end up calling in the UI portion of your code. Within your App’s folder/directory, there needs to be a sub-folder/directory called www. This is the place where you’ll need to place ALL static image files. 3.6.3.1 Adding an Image To include the image in your App, you’ll need to make use of the image tag, img. When you run your App, Shiny automatically knows to check the www folder any time the img tag gets called. Here is an example supposing that the check mark image for correct answers is in the app’s www folder: #[code omitted] div(align = &quot;right&quot;, img(src = &quot;check.PNG&quot;, alt = &quot;Success, you are correct&quot;, width = 25, #these are in pixels height = 25, )) #[code omitted] You’ll notice that we’ve wrapped the img call in a div call. The div call allows us to specify that we want the image to be right aligned; you could also do left or center. You can replace the div call with the paragraph environment and include text on either side, effectively making your image part of the text. #[code omitted] p(&quot;Check your answer here --&gt;&quot;, img(src = &quot;check.PNG&quot;, alt = &quot;Success, you are correct&quot;, width = 25, height = 25), &quot;&lt;-- Check your answer here&quot;), #[code omitted] 3.6.3.2 Sizing and Positioning Your Image All image files have a native size that is part of that file. For instance, the check mark image is 270 x 250 pixels. However, we overrode that that sizing with the width and height arguments. How did we decide on 25 x 25? Honestly, through guess and checking. You’ll need to think about how you’re using the image and let that guide your decision making. There is no one size fits all solution. While finding an optimal size and position for your image can take some time, seeing bad settings is pretty obvious. Feel free to reach out to Neil and Bob for assistance. 3.6.4 Alt Text Any graphical element you include in your App MUST have an alternative (assistive) text description (“alt text”). This provides a short description of what is in the image or plot for users who are visual impaired. (Tables, when properly formatted will handle this automatically.) A good resource to check out is the WebAIM Alternative Text page. 3.6.4.1 Adding Alt Text to Static Images In the prior section on static images, you saw exactly how to set the alt text; here is a generic example: #[code omitted] img(src = &quot;yourImage.PNG&quot;, alt = &quot;Short description of what&#39;s in the pic&quot;, width = 25, height = 25) #[code omitted] 3.6.4.2 Adding Alt Text Graphs This section is under construction. 3.7 Miscellaneous Consider adding a loading bar to show the process for intense computations; this will help the user understand that your App is processing and not frozen/broken. "],
["wording.html", "Chapter 4 Wording 4.1 General Guidelines 4.2 Popovers 4.3 Dealing with Differing Vocabularies 4.4 Footnotes", " Chapter 4 Wording This chapter focuses on the wording that we use within the BOAST Apps. 4.1 General Guidelines When writing the content for your App, you will want to keep in mind that our apps have students as the primary audience. Thus, we need to make sure that we use language that is appropriate. Seek to use complete sentences that convey what you intend. Have someone else take a look at your content and then tell you what they believe the text to be saying. If what they say is consistent with what you intended, great. If not, then you need to revise your text. DO NOT sacrifice clarity and precision/accuracy for conciseness/brevity. While we don’t necessarily want a wall of text, there should still be some text to assist the user. Since these apps are for teaching and learning, we need to use language that is accurate and supports students in constructing productive meanings. This means that we need to avoid sloppy language, re-enforcing problematic conceptions, and supporting fallacies. For example, Sloppy Language: Vagueness BAD: “We want to explore how these averages differ.” NEUTRAL/FAIR: “We want to explore how these means differ.” _ GOOD: “We want to explore how the values of the sample arithmetic mean (SAM) varies between these groups.” Sloppy Language: Discussing values of statistics BAD: “The mean is 6.” GOOD: “The value of the sample arithematic mean for this data is 6 units/object.” Problematic conceptions BAD: “Probability is the likelihood of an event in relation to all possible events.” GOOD: “Probability is the long-run relative frequency for us seeing a particular data event given our assumptions. Likelihood is the long-run relative frequency of a set of assumptions being true given our collected data.” Fallacies BAD: “We’re 95% confident that the true population proportion is between 0.35 and 0.45.” GOOD: “If we were to repeat the entire study infinitely many times, then 95% of the time we will make an interval that captures the true population proportion.” 4.2 Popovers The term “Popovers” refers to any number of different tools on websites that go by other names such as tooltips, rollovers, and hover text. In essence, this tool appears when the user places their cursor over (i.e., hover) or shifts the focus to a trigger object (typically user inputs or graphs). The text then pops up on the screen for the user to view. The function to create one of these in a Shiny app is shinyBS::bsPopover. While these can be powerful, they are often misused, leading to problems. For example, they can prevent the user from actually interacting with portions of your app when they appear. Popovers are meant to provide short, simple clarifications; quick annotations which enrich the content that is already present. This type of text is meant to be temporary, only appearing for as long as the user is hovering/focusing on the trigger object. Thus, if you are putting information that is critical for a person to successfully use your App in a popover, you are using popovers INCORRECTLY. Here are few additional sources for reading about Popovers/Tooltips: Tooltips in UI Design Tooltips: How to use this small but mighty UI pattern correctly Restrict any usage of a popover to something short and non-vital for your App’s user. If you do choose to use a popover, you will need to format the popover correctly. Be sure that your function call includes values for the following arguments: id: this needs to be the name of the object which will act as the trigger title: this will be a string that appears across the top of your popover; use verbs with an understood “you” (e.g., “Investigate!”, “Remember”, etc.) content: this will be the string that you want displayed; shorter is better. placement: this will control where the popover appears. Choose the option (top, bottom, left, right) that works best for your space. Ensure that the placement does not cover any controls or other vital information. The visual appearance of the popover will be control by the central BOAST CSS file. 4.3 Dealing with Differing Vocabularies One of the most challenging aspects of Wording is the fact that we have to deal with the Jingle/Jangle problem. 4.3.1 The Jingle/Jangle Problem A term “jingles” when people use that term to refer to two (or more) different concepts. This is also know as a term having lexical ambiguity. For instance, random jingles when people use the term to convey haphazardness, arbitrariness, and/or an attribute of process. (Note: the only the third option is statistically valid.) On the other hand, a set of 2+ different terms “jangle” when they refer to the same concept. A good/classical example of this is skewness. Some people talk about left/right skewness, others negative/positive skewness, and others will talk about long left/long right tails. Each of these pairs refer to the same core concept, but evoke different mental images. 4.3.2 Option 0: Dictionary/Thesaurus There are a variety of ways in which we could handle this approach. One thought is to build a Dictionary/Thesaurus for BOAST. While we could go down this route, this represents a considerable undertaking and might become a long term goal. 4.3.3 Option 1: Hover Text The more immediate solution to differing vocabularies is for us to make use of hover text. This approach is appealing in that the user doesn’t have to leave your App (like going to a dictionary/thesaurus) and the content of these tips is not critical to using your App. That is to say, the information is available for those who might need a quick reminder but does not take up permanent screen space. To use this tool you’ll need to make sure that you install and load the tippy package. install.packages(&quot;tippy&quot;) Suppose that we want to add the hover text to the the word “positive” in the following sentence: A positively skewed histogram will hoave potential outliers that are larger than the main modal clump(s). We would need to do the following in our app.R (or ui.R) file: library(tippy) #[code omitted] dashboardPage( skin = &quot;blue&quot;, dashboardHeader( #[code omitted] ), dashboardBody( #[code omitted] tabItem( tabName = &quot;Overview&quot;, h1(&quot;Exploring Skewness&quot;), p(&quot;A &quot;, tippy::tippy(text = &quot;positively skewed&quot;, tooltip = &quot;Sometimes called &#39;long right tail&#39; or &#39;right skewed&#39;&quot;, arrow = TRUE, placement = &quot;auto&quot;), &quot; histogram will have potential outliers that are larger than the main modal clump(s).&quot;), #[code omitted] ))) There are several things to notice in the example: The tippy call is part of the paragraph environment. If the text is going to be part of a list, then the tippy call should be part of a list item. There are four (4) required arguments: text—the words that will be part of the page tooltip—the words that will appear/disappear when the user hovers/focuses on the text arrow = TRUE—this creates an arrow from the tooltip to the text. Make sure to set this as TRUE placement—controls where the the tooltip appears in relation to the text. While there are multiple values you could use here, we recommend using auto to allow the App to determine the best position. If you want to override this, then you should use values of top(shows above) orbottom (shows below). Be sure to include spaces around text that appears before and after the tippy element. Don’t forget to put commas between the text and the tippy element. These won’t appear in your App but allow R to see that there are multiple elements. 4.3.3.1 Choosing Terms-Jangle If you are going to make use of hover text to combat a jangle problem, you are going to have to make a decision about what words/phrase will be part of the app (i.e., the text) and which words/phrases will be part of the hover text (i.e., the tooltip). You should make this decision in conjunction with a faculty member. Our recommendations are to use the word or phrase which: Best supports students in building productive meanings Best supports students in seeing coherence between a variety of concepts Appealing to “tradition” or “this what most people do” IS NOT a valid justification. Again, these apps are to support students in building their understandings, we must do better. In the tippy example above, the ordering of terms is: positively skewed long right tail right skewed This ordering reflects the ordering of most productive and coherent. “Positively skewed” works regardless of the orientation of the histogram (see Figure 4.1) as well as directly connecting to the statistic sample skewness. The later two only make sense in one orientation and do not connect to sample skewness. “Long right tail” is preferable to “right skewed” as this phrasing helps students avoid the common belief that the position term (right/left) is about where the bulk of the observations are. Figure 4.1: Same Data, Two Orientations 4.3.3.2 Choosing Terms-Jingle We will always use the statistical/probabilistic meaning for a term, never the colloquial/everyday/non-technical meaning(s). 4.3.4 Option 2: Entry on the Prerequisites Tab/Page Another option that you could do for both the jingle and jangle problems is to add an entry on the Prerequisites page. If you only have a jangle problem, you can use the Hover Text option. Option 2 can be combined with Option 1. 4.4 Footnotes We recommend avoiding footnotes in favor of Hover Text. "],
["documentation.html", "Chapter 5 Documentation 5.1 References 5.2 Plagiarism 5.3 R Packages 5.4 Graphics 5.5 Data", " Chapter 5 Documentation These apps are the product of your hard work and are part of your academic record. Thus, you need to adhere to Penn State’s Academic Integrity Policy. This is especially important as we are making the apps available through a Creative Commons Attribution-ShareAlike 4.0 International license (CC BY-SA 4.0). If you have used code, pictures, data, or other materials from outside of the BOAST team, you MUST give proper credit. These references will then be included on the App’s References Tab. 5.1 References All apps will need a References Tab. This is where you’ll place all references for your App, including R packages, borrowed code, data sources, images, etc. This in addition to the Acknowledgments. NOTE: listing something in the Acknowledgments DOES NOT waive this requirement. You may use any citation style you wish, but be consistent. Recommended citation styles include APA and AmStat. Here is a starting code block for you to use: #[omitted code] tabItem( tabName = &quot;refs&quot;, withMathJax(), h2(&quot;References&quot;), p(class = &quot;hangingindent&quot;, &quot;reference 1-alphabetically&quot;), p(class = &quot;hangingindent&quot;, &quot;reference 2-alphabetically&quot;), # Repeat as needed ) Notice the use of class = \"hangingindent\". You must include this with each reference as this will ensure the proper styling of your references. If you need assistance with this section, please talk to Neil. 5.2 Plagiarism You MAY NOT use blocks of code you’ve found online without giving proper attribution. There is a difference between looking at example code online to see how to do something and copying that code directly. The former is permissible, the later is plagiarism. If you want to use someone else’s code “as is” (without any changes), you should reach out to the author for permission first. If you use someone else’s code and make modifications, you need to give credit to where you got the code, and potentially ask for permission. You will need to place citations in two places: in the References Tab and in your code. You might want to also consider adding an acknowledgement to the Overview tab. 5.2.1 Reference Tab Use the following format: Author. (Date). Title of program/source code (Version number, if applicable). [type of code]. Retrieved from &lt; URL &gt;. For example, Hatfield, N. J. (2017). First day activity (v1). [Netlogo]. Retrieved from https://neilhatfield.github.io/statApps/Day1Activity.html. 5.2.2 In Code Use the following format in your code to cite where you got the code from. #------------------------------------------------------------------------------- # Title: &lt;title of program/source code&gt; # Author: &lt;author(s) names&gt; # Date: &lt;date&gt; # Code version: &lt;code version&gt; # Availability: &lt;where it&#39;s located&gt; #------------------------------------------------------------------------------- # [borrowed code then follows] # ... # [last line of borrowed code] #End of &lt;author&gt;&#39;s code---------------------------------------------------------- 5.3 R Packages If you made use of any packages in R, then you will need to add these to the Reference tab. Fortunately, there is a built-in tool that will help you: the citation function. In R (RStudio) simply type citation(\"packageName\") and you’ll get the appropriate citation information for the package you used. For example, citation(\"shinydashboard\") and citation(\"plyr\") will give the information needed for the following citations: Chang, W. and Borges Ribeio, B. (2018). shinydashboard: Create dashboards with ‘Shiny’. (v0.7.1) [R Package]. Available from https://CRAN.R-project.org/package=shinydashboard Wickham, H. (2011). The Split-apply-combine strategy for data analysis. Journal of Statistical Software, 40(1). pp. 1-29. Available at http://www.jstatsoft.org/v40/i01/. Notice, that the format of the R package will depend on whether there is an article published for the package. The shinydashboard package is not associated with an article while the plyr package is associated with Wickham’s article. 5.4 Graphics Pictures, drawings, photographs, images, etc. are typically copyrighted. When you’re selecting images, make sure that the images are Open Source/Copyright Free/Royalty Free/Public Domain. Additionally, include a reference to where the pictures came from in the Overview Page. The basic format to use is: LastName, First Initial. (Year). Title of artwork. [Format]. Retrieved from &lt; URL &gt;. 5.5 Data If you are using any data files, you need to attribute where those files are coming from in the References tab. You might also want to add an acknowledgement on the Overview tab. A suggested format to use is: Author/Rightsholder. (Year). Title of data set (Version number) [Description of form]. Location: Name of producer. Author/Rightsholder. (Year). Title of data set (Version number) [Description of form]. Retrieved from http://www.url.com If you (or someone else) had to sign some type of agreement to access the data, we must examine the agreement before you make your App publicly accessible. Just because you got access to the data does not mean you have the right to share the data. "],
["accessibility.html", "Chapter 6 Accessibility 6.1 Testing Accessibility", " Chapter 6 Accessibility We need to make sure that our Apps are accessible. If you have been adhering to the style guide, your App should be in a decent position. When you’re ready to test the accessibility of your App, you’ll need to deploy the App to a sever and then use the WAVE Web Accessibility Evaluation Tool. Enter the URL of your App in the noted box to run an evaluation. See what accessibility issues your App has and then address them. See also: Accessibility and Usability at Penn State Accessibility Statement How to Meet Web Content Accessibility Guidelines 7 Things Every Designer Needs to Know about Accessibility 6.1 Testing Accessibility We highly recommend using the WAVE Web Accessibility Evaluation Tool. Figure 6.1: WAVE Report for Descriptive Statistics App Figure 6.1 shows the WAVE report for the Descriptive Statistics App. There are 54 errors including missing alternative text, empty headings. There are also 8 contrast errors, 14 alerts (skipping heading levels), Figure 6.2: WAVE Report for Overfitting App While there are fewer errors for the Overfitting App (Figure 6.2), there are a lot of alerts on this app including skipping heading levels and small text. By using the boastApp function and adhering to this Style Guide, your App should be in a good initial position. After running your App through WAVE, we can work with you address any changes that might be necessary. "],
["mobile.html", "Chapter 7 Mobile Friendliness", " Chapter 7 Mobile Friendliness We want our apps to work well with mobile devices. Thus, when you get to the point where the majority of bugs have been fixed, you need to check how mobile friendly your App is. If you have used boastApp and/or the boast.CSS file, along with the practices laid out earlier, then you should be well on your way to being mobile friendly. You can check your App in two ways: Test your App out on a variety of mobile devices. Make use of a browser’s ability to mimic devices. To do this, launch your App in a browser, then enable one of the following: Chrome: Device Mode Firefox: Responsive Design Mode Microsoft Edge: Device Emulation Safari: Responsive Design Mode Look for any issues that you might be able to address before you hand off your App for others to play around with. Assign a Mobile Friendliness Rating to your App on a scale from 1 to 5. Not functional Functional – Very awkward Functional – Okay if no big screen available (multiple issues) Usable in a small class setting (single issue) Readily usable "],
["addTools.html", "Chapter 8 Additional Tools", " Chapter 8 Additional Tools Here are a few additional tools that can help you with App development: lintr - Checks adherence to a given style, syntax errors, and possible semantic issues. styler - Format R code according to a style guide. funchir - stale package check R Code install.packages(c(&quot;funchir&quot;, &quot;lintr&quot;, &quot;styler&quot;)) "]
]
