[
["visualAppearance.html", "Chapter 3 Visual Appearance 3.1 PSU Branding 3.2 Dashboard 3.3 Common Elements 3.4 Colors 3.5 Text Styling 3.6 Graphics 3.7 Miscellaneous", " Chapter 3 Visual Appearance This chapter of the BOAST Style Guide deals with the Visual Appearance of each app. Visual Styling encompasses not only text styling but also color scheme usage, graphics (images, plots, tables), and the dashboard layout. For each app, there are 6 major components to the Visual Appearance that you will need to consider: PSU Branding, the Dashboard, Common Elements, Color, Text Styling, and Graphics. One of the most important benefits of using the boastApp function from the boastUtils package is that is that much of the Visual Appearance will be automatically handled for you. However, you should still familiarize yourself with the Visual Appearance Style for our apps. 3.1 PSU Branding Given that we are all associated with Pennsylvania State University, we need to include the Penn State logo in each App. Rather than sticking the logo at the top of the Overview page, we are going to place the logo at the bottom of the sidebar. This has the benefit of having the logo appear throughout the entire App AND making the logo be as unobtrusive as possible. In your UI section of app.R (or the ui.R file), at the end of the dashboardSidebar() section, you will need to include the following: tags$div(class = &quot;sidebar-logo&quot;, boastUtils::psu_eberly_logo(&quot;reversed&quot;)) Here’s how this code would look in context: dashboardPage( skin = &quot;blue&quot;, dashboardHeader( title = &quot;title&quot;, # [omitted code] ), dashboardSidebar( width = 300, sidebarMenu( id = &quot;tabs&quot;, # [omitted code], tags$div( class = &quot;sidebar-logo&quot;, boastUtils::psu_eberly_logo(&quot;reversed&quot;) ) ), dashboardBody( tags$head( tags$link(rel = &quot;stylesheet&quot;, type = &quot;text/css&quot;, href = &quot;https://educationshinyappteam.github.io/Style_Guide/theme/boast.css&quot;), tabItems( # [omitted code] ) ) ) ) ) This will ensure that the Penn State logo gets properly used. 3.2 Dashboard All apps will make use of a Dashboard structure. This divides the visual appearance of each App into three main areas. Across the top of the App will be the Header Along the left side of the App will be the navigation list (the Sidebar) where the various Tabs (pages) of your App will be listed The last area is the Body; this is where all content will appear 3.2.1 Dashboard Header Each Dashboard Header contains only a couple of elements. The most important of these will be a [shortened] Title of your App. This will automatically be followed by the sidebar collapse/expand button. At the far right, you will then include a link to the home page of BOAST using the Home icon. Additional icons might be included to the left of the Home icon. However, these icons remain the same for all Tabs/pages of your App and are thus are not appropriate for Tab/page specific information. There should not be any additional elements in the Dashboard Header. Any links for navigate in your App should appear in the Sidebar on the left edge. The width of the Title component of the Header should be 300; titleWidth = 300. 3.2.2 Sidebar and Body The Sidebar (responsible for App navigation) and the Body are intimately related to one another. The Sidebar provides structure to your App as well as being the primary way that a user can move around the App. The Body is where all content (text, images, plots, buttons, etc.) exists for the user to read, view, and interact with. The Sidebar should have a width of 300, (width = 300). To ensure a consistent experience across all apps, you need to make sure that your App has the following tabs/page, in the following order: 3.2.2.1 The Overview Tab This Tab is REQUIRED for all Apps. This is the main landing page of your App and should appear at the top of the sidepanel. The icon for this Tab must be “dashboard”. The Overview Tab must contain ALL of the following elements: “Title” (as Heading 1) A description of the app (as paragraph text under the title) “Instructions” (as Heading 2) General instructions for using the App (using an Ordered List environment) A button that will take the user to the next Tab/page. “Acknowledgements” (as Heading 2) A listing of acknowledgements including, coders, content writers, etc. (as a paragraph) Last Element: div(class = \"updated\", \"Last Update: mm/dd/yyyy by FL.\") with mm/dd/yyyy replaced with the date of the update you pushed to the server and FL replaced with your initials. There is no need to use boldface or colons with the section headings when you properly use Heading tags. Thus, “Instructions:” does not follow this Style Guide. Additionally, there should not be an “About” heading. 3.2.2.2 A Prerequisites Tab If your App needs to ensure that the user has the base understandings necessary to interact with your App, you’ll need to create a prerequisites Tab. Otherwise, skip this Tab. The icon for this Tab must be “book”. Use the word “Prerequisites” rather than “Pre-reqs”, “Prereqs”, or “Pre-requisites”. Keep in mind that there are two different types of prerequisites: technical/conceptual and contextual. Both of these go into the Prerequisites tab. Technical/Conceptual Prerequisites cover ideas that the user needs in order to fully engage with your App’s statistical goal. For instance, if your App is about ANCOVA, the ideas of ANOVA and building a linear model would be good candidates for technical/conceptual prerequisites. Contextual Prerequisites cover ideas that which are beneficial for the user to understand a context you’re using. For example, if you are referencing an astragalus, you should include a brief explanation and/or picture of an astragalus. Keep in mind that Contextual Prerequisites are different than context which should be part of the Activity Tab. If the information is necessary to interpret sliders/graphs and is specific, then you should include this information in the Activity Tab. If the information helps the user say “Oh, that’s what they mean by [blank]”, that is good sign of something to put in the Prerequisites Tab. 3.2.2.3 Activity Tab(s) This is the heart of your App and you are required to have at least one. In the event you have multiple activities, each one will need a separate Tab. The order of these Tabs will depend upon the your goals for the App. Each Tab should contain all information/instructions for the user to be able to interact with the activity without having to switch to other Tabs. The icon you use depends on the type of activity: Games will use the icon “gamepad”. Explorations will use the icon “wpexplorer”. Challenges will use the icon “gears”. 3.2.2.3.1 General Layout for Activity Tabs For the vast majority of Activity Tabs, we will adopt a 3-part layout: Across the top will be any general information the user needs to interact with your App as well as an context information. To the left and wrapped in a well panel will be the inputs/controls that the user will need to manipulate. To the right and NOT in a well panel will be the outputs (graphs, images, R output) There will be some cases where this general layout does not necessarily work. For instance, Tic-Tac-Toe games will not follow this layout. 3.2.2.4 References The last Tab will be for your references. This Tab is REQUIRED and is where you will place a reference list for all of the following items that you used in your app: All R packages you used Sources of any Code you used directly or drew heavily upon from other people Pictures and/or other images Data sets Refer to the Documentation Section (5) of this Style Guide for more information. The icon for this Tab must be “leanpub”. 3.2.2.5 Last Element The last element of the Sidebar will be the Penn State Logo. Please refer to the Section 3.1. 3.2.3 Tabs Inside the Body There are two types of tabs in a Shiny app: there are the tabItem (i.e., the pages within an app and should appear in the Sidebar) and tabPanel (i.e., creating sub-pages or independent sections). In this section, we will discuss this later case. Deciding on whether to use tabPanel is going to depend on several things: Do you have two or more aspects that are related enough that they shouldn’t be their own separate tabs/pages of your App? If NO, then you shouldn’t use tabPanel. If YES, then continue. Are any of your aspects something that would be better suited as a Challenge or Game tab? If YES, move that aspect to a separate page. If you still have 2+ aspects, continue. If NO, continue. Are the aspects independent enough that a person can skip a couple and still use the App successfully? If NO, then you should re-consider your design. If YES, then proceed with using tabPanel in you design. When you go to make a set of tab panels you will need to first create a tabsetPanel which will wrap around all of the individual panels. Use type = \"tabs\". The tabs inside the body should automatically appear horizontally and along the top of the tab body (i.e., in the white space below the Dashboard Header). Any visual styling will be managed by the BOAST CSS file at a global level. 3.3 Common Elements In addition to the Dashboard elements of the apps, there are other elements that are common. This include things such as how inputs should be ordered, buttons, correct/incorrect indicators, and animation buttons. For information about popovers, rollovers, hover text, or tooltips, please see Section 4.2. 3.3.1 Ordering Inputs One of the most powerful aspects of Shiny apps is that the user interacts with them. Thus, we do need to consider not only the ways in which user interact (e.g., buttons, sliders, text entry, etc.) but also the order in which you want the user to manipulate the inputs. Coming up with a single declaration for how to order inputs in all cases is not necessarily feasible. However, we can set up a general guideline for how to make decisions on ordering your inputs. Please use the following guidelines for determining the order of inputs in the User Interface (UI): In general, if you want your user to do things in certain order, make your inputs appear in that order. For example, If you want them to pick a data set, then an unusualness threshold/significance level, what attribute to test, and then set a parameter value, then your inputs should appear in that order. Make use of how we read the English language, i.e., Top-to-Bottom and Left-to-Right to provide an implicit ordering for your user. If a user needs to carry out steps in particular sequence for your App to run properly, then place your inputs inside of an Ordered List environment with explicit text on what they should do. For example, Choose your data set: [dropdown] Set your unusualness threshold/significance level [slider] Which attribute do you want to test: [dropdown] What parameter value do you want to use: [numeric input] If an input is going to reset other inputs you should either: Warn the user before hand Move the input to the top of the list Program the input to not reset other inputs Some combination of the above If the inputs are not dynamically linked to the output (e.g., plots automatically update with a change in the input’s value), then you should include a button that says “Make Plot” at the end of the inputs. 3.3.2 Buttons Buttons are one way in which users interact with the apps. The two most common functions that are used are shiny::actionButton and shinyBS::bsButton. Both functions share many of the same features. Two ways in which they are different is that shinyBS::bsButton has an additional style argument while shiny::actionButton has a width argument that gives you fine grain size control (bsButton just has a qualitative size option). There are three key styling aspects: shape/animation, color, and text &amp; icon. 3.3.2.1 Shape/Animation All shape aspects of buttons will be controlled by CSS. The standard shape will be rectangular (the default). Sizing will be controlled by CSS although setting size = \"large\" for the bsButton call may be done. We have a number of apps where a button will change shape/size when a person hovers their cursor over it. This “animation” is to be discontinued. This is to say that buttons which change shape/size should be flagged as issues and resolved at the first opportunity. At most, the button’s color might change (e.g., lighten or darken), depending on the context. 3.3.2.2 Color The coloring of the button will also be controlled by CSS in one of two ways. The default way will be through the BOAST CSS. This will ensure that the selected color scheme for your App will be consistent. The second way only applies to bsButton and the style argument. Here, this option references an external CSS file beyond BOAST. We see these most often in games. Use the following list to guide you in choosing which style: warning: Good for when you want the user to proceed with caution; for example a submit button in a game. danger: Good for when you want the user to think twice before clicking; for example, a reset game button. success: Good for when you want to convey that the user can proceed safely; for example, a button that advances the user through the game info: Good for when you want to give some additional information; for example, a button that triggers game instructions popping up, a button that gives a hint, or a button that might filter a question pool. When in doubt, use the the default style option (or even omit this argument) for bsButton or use actionButton. 3.3.2.3 Text &amp; Icon The last styling element of a button is two-fold: the text that is in the button and the icon. Here are some guidelines for text of a button: All buttons must have some text. Generally speaking, the text should be relatively brief and clear. Don’t use “Go to the next page” when you could use “Next” The text should make sense with the action of the button; for example, “Reset” if the button resets something (a game, a plot, inputs) “Submit” if the button triggers the app to grab and process input values “Make Graph” if button causes a graph to be generated “Show/Hide Graph” if a button makes a graph object appear/disappear “Next” if a button moves the user along some path. If the button references something like a particular tab (prerequisites, exploration, etc.), the text should reflect this. “Explore!” for a button that takes a user to an Exploration tab. “Prerequisites” for a button that takes a user to a Prerequisites tab. “Challenge Yourself!” for a button takes a user to a Challenge tab. “Play!” for a button that takes a user to Game tab. If a button references an object like an activity packet or a download prompt the text should refer to that “Activity Packet” for a button that would open up and/or download a packet for the user “Download Data” for a button that would download a data file. Clarity is essential. If there are multiple buttons on the page, make sure that you use clear text for what button does and/or references. Here are guidelines for the inclusion of icons in a button: Game buttons will NOT have any icons. Direction Buttons (e.g., “Next” or “Previous”) will NOT have any icons. Rather make the button text “&lt;&lt; Previous” or “Next &gt;&gt;” A “Prerequisites” button will use the “book” icon All other tab buttons (labels ending with “!”) will use the “bolt” icon. A download button will use the “cloud-download” icon. 3.3.3 Correct/Incorrect Marks In games, you can give the user a visual cue as to whether they are correct or incorrect through the use of two images: Figure 3.1: Correct/Incorrect Marks You can save these two images by right-clicking on them and selecting “Save Image As…”. You will need to put them in the www folder/directory of your App. Their placement in your App will depend upon what makes the most sense. 3.3.4 Animation Buttons One feature of slider inputs is the option to include a Play/Pause button that allows the user to create an animation of your plot. Enabling this option can be quite useful if allowing the user to move through the whole set of slider values is desirable. To enable this, you’ll need to make use of the animate argument: #[code omitted] sliderInput( inputId = &quot;mtcAlpha&quot;, label = &quot;Set your threshold level, \\\\(\\\\alpha_{UT}\\\\):&quot;, min = 0.01, max = 0.25, value = 0.1, step = 0.01, animate = animationOptions( interval = 1000, loop = TRUE)) #[code omitted] You can set animate=TRUE, animate=FALSE or invoke the animationOptions function as we’ve done in the example and recommend. This will force you to make some important decisions: namely, how long the slider should wait between each movement (interval, in milliseconds) and should the animation start over once the slider reaches the maximum (loop). The interval is going to the most challenging value to figure out. This timer ignores everything else; that is, it doesn’t wait to see whether your plot has updated. Remember, the more complicated the process is that generates your plot, the longer your App will need to render the plot. Thus, you can quickly get into a case where the slider has advanced several times while your App is still trying to render the first update. While renderCachePlot can help speed things up, keep in mind that you still might need to play around with the interval value to ensure smooth functionality. Make sure when you’re testing an animated slider to vary all of the parameters involved in the graph. This will help ensure that you test adequately. The styling of the play/pause button will be controlled by the BOAST CSS file. 3.4 Colors Your App needs to have a consistent color scheme throughout. The color scheme should be checked against colorblindness to meet WCAG 2.1 Level AA. You can do so at the Coloring for Colorblindness website. If you are following this Style Guide (as you should be) then the vast majority of this section will be automatically handled for you. There are two major places where coloring comes into play: the user interface and plots you generate in R. 3.4.1 Color in the User Interface Within BOAST, we use color themes to help provide consistency for the elements of each app and to denote different chapters. Part of the standardization process with the Style Guide seeks to bring the many fractured color themes together into a cohesive, centrally managed set. This helps reduce the programming burden from the students, who should focus on the R side of the programming, not the CSS side. All aspects of color in the User Interface should be controlled through the CSS file(s). This includes all of the following: Dashboard coloring (Header, Sidepanel, Body) Text coloring Coloring of Controls (including buttons, sliders, and other input fields) By using CSS, especially through boastApp, you’ll be able to ensure that there is consistent coloring throughout your App. 3.4.1.1 Implementing a Color Theme To activate a color theme is a simple process, especially if you are following this Style Guide and using the boastUtils package. (If you are in an App using ui.R and server.R, make sure that the boast.css call is in the ui.R file.) In your App’s code, go to where you first call the function dashboardPage. Then, as the first argument you’ll type skin = \"[theme]\" before moving on the next argument, dashboardHeader. You will replace [theme] with one of the following: blue, green, purple, yellow, red or black. The choice will be determined by the color assigned to that chapter. This is all you have to do. If you are unsure what color to put, use blue as the default. 3.4.1.2 The Themes There are six color themes that we’ve currently made. The names of the themes are a general indication of coloring, with one exception. The black theme is not black but rather an aqua/teal set. The themes are typically three colors (four for blue) and based upon the Penn State Palettes. Non-Penn State colors will be denoted with asterisks. All of the themes have been checked against 8 different forms of color blindness. 3.4.1.2.1 Blue The Blue Palette is our central palette and should be used by default. The Blue Palette looks like the following: Figure 3.2: The Blue Palette Here is what the Blue Palette looks like in action: Figure 3.3: Overview Page Using the Blue Palette Figure 3.4: Collapsible Boxes Using the Blue Palette Figure 3.5: Sliders Using the Blue Palette 3.4.1.2.2 Green The Green Palette looks like the following: Figure 3.6: The Green Palette Here is what the Green Palette looks like in action: Figure 3.7: Overview Page Using the Green Palette Figure 3.8: Collapsible Boxes Using the Green Palette Figure 3.9: Sliders Using the Green Palette 3.4.1.2.3 Purple The Purple Palette looks like the following: Figure 3.10: The Purple Palette Here is what the Purple Palette looks like in action: Figure 3.11: Overview Page Using the Purple Palette Figure 3.12: Collapsible Boxes Using the Purple Palette Figure 3.13: Sliders Using the Purple Palette 3.4.1.2.4 Black The “Black” Palette is not pegged to the color black, but rather teal/aqua colors. However, to call the theme in the Shiny dashboard, the user must use the value black for the the skin argument. Here’s what the “Black” Palette looks like: Figure 3.14: The ‘Black’ Palette Here is what the “Black” Palette looks like in action: Figure 3.15: Overview Page Using the ‘Black’ Palette Figure 3.16: Collapsible Boxes Using the ‘Black’ Palette Figure 3.17: Sliders Using the ‘Black’ Palette 3.4.1.2.5 Yellow The Yellow Palette is still under consideration. The current set looks like the following: Figure 3.18: The Yellow Palette Here is what the Yellow Palette looks like in action: Figure 3.19: Overview Page Using the Yellow Palette Figure 3.20: Collapsible Boxes Using the Yellow Palette Figure 3.21: Sliders Using the Yellow Palette 3.4.1.2.6 Red The Red Palette is still under construction. Here’s the current set: Figure 3.22: The Red Palette Here is what the Red Palette looks like in action: Figure 3.23: Overview Page Using the Red Palette Figure 3.24: Collapsible Boxes Using the Red Palette Figure 3.25: Sliders Using the Red Palette 3.4.1.3 Current Chapter Color Assignments Here are the current (05/27/2020) color theme assignments for chapters: Chapter 1: Data Gathering RED Chapter 2: Data Description YELLOW Chapter 3: Basic Probability BLUE Chapter 4: Statistical Inference PURPLE Chapter 5: Probability BLUE Chapter 6: Regression “BLACK” Chapter 7: ANOVA “BLACK” Chapter 8: Time Series PURPLE Chapter 9: Sampling RED Chapter 10: Categorical Data YELLOW Chapter 11: Data Science GREEN Chapter 12: Stochastic Processes BLUE Chapter 13: Biology GREEN 3.4.2 Color and Plots in R In R you can set color theme which you use in ggplot2. Here are two custom color palettes that you can use in your App. Additionally, the package viridis provides several additional color palettes which are improvements upon the default color scheme. # boastPalette is based on the Wong color blind set found at the above website. boastPalette &lt;- c(&quot;#0072B2&quot;,&quot;#D55E00&quot;,&quot;#009E73&quot;,&quot;#CE77A8&quot;, &quot;#000000&quot;,&quot;#E69F00&quot;,&quot;#999999&quot;,&quot;#56B4E9&quot;,&quot;#CC79A7&quot;) # psuPalette is based on Penn State&#39;s three official color palettes # and checked at the above webite. psuPalette &lt;- c(&quot;#1E407C&quot;,&quot;#BC204B&quot;,&quot;#3EA39E&quot;,&quot;#E98300&quot;, &quot;#999999&quot;,&quot;#AC8DCE&quot;,&quot;#F2665E&quot;,&quot;#99CC00&quot;) # Both palettes get used in the order of what is listed. To use these palettes (or ones from viridis) with a ggplot2 object, you’ll need to doe the following # You will need to first add whichever palette line from above to your code boastPalette &lt;- c(&quot;#0072B2&quot;,&quot;#D55E00&quot;,&quot;#009E73&quot;,&quot;#CE77A8&quot;, &quot;#000000&quot;,&quot;#E69F00&quot;,&quot;#999999&quot;,&quot;#56B4E9&quot;,&quot;#CC79A7&quot;) # Create ggplot2 object g1 &lt;- ggplot2::ggplot(data = df, aes(x = x, y = y, color = grp, fill = grp)) # Add your layers g1 + ggplot2::geom_points() # Tell R to use your chosen palette g1 + ggplot2::scale_color_manual(values=boastPalette) # If you use &quot;color&quot; in aes g1 + ggplot2::scale_fill_manual(values=boastPalette) # If you use &quot;fill&quot; in aes If you have more groups than eight/nine colors listed in the two palettes, consider reworking your examples as you could overwhelm the user with too many colors. (This also applies to using different shapes to plot points.) With any eye towards accessibility, try not to use only color to denote a particular piece of information. Rather you might want to use color and shape. 3.5 Text Styling Text styling refers the non-content aspects of the text on the page. This means things such as the use of italics, boldface, alignment, as well as font size and color. You should let the centralized CSS file do the heavy lifting for text styling. (Again, using boastApp will help you.) However, for this to work properly, you will need to tag content appropriately. (See the HTML section: 2.1.5) If you run into a situation where some element needs additionl styling, talk to Neil or Bob for help. You might have come across an element that needs to get added the central CSS file or a bug. 3.5.1 Headings Use the Heading Tags for the short fragments that define the structure of your App. If you find yourself enclosing a complete sentence in Heading tag, you ARE NOT using headings correctly. Notice how the headings in this Style Guide aren’t complete sentences; your App should mimic this. Full sentences appear as regular paragraph text (i.e., enclosed in p()) and not be a Heading. 3.5.2 Paragraph Text If you enclose text that gives instructions or other information to your App’s users in p() or li() (the later should be wrapped in either tags$ol() or tags$ul()), your App will understand how to style that text correctly. The central CSS file contains controls that set the base font size much larger than Shiny does natively as well as making text sizing dynamic. (This is important for making our apps mobile device friendly.) Again, using boastApp makes this process easier. If you want to make a certain word or phrase italic, you will need to wrap that text in tags$em(). Similarly, if you want do the same with boldface, you’ll use tags$strong(). For example, this code: p( &quot;When dealing with the &quot;, tags$em(&quot;t&quot;), &quot;-distribution, we only have one parameter, the &quot;, tags$strong(&quot;degrees of freedom&quot;), &quot;that we need to input.&quot; ) Becomes: When dealing with the t-distribution, we only have one parameter, the degrees of freedom that we need to input. Use italics (emphasis), and boldface (strong) sparingly. 3.5.3 Mathematics For the most part, any mathematics you need displayed should be done using MathJax. Default to using inline typesetting with the \\\\( and \\\\) delimiters. If you need to use display style, you can use \\\\[ and \\\\]. For the vast majority of mathematics, you’ll wrap both inline and display style mathematics inside of a paragraph environment (p()). If you’re writing mathematics directly in your app, remember you’ll need to escape the LaTeX commands by putting an extra backslash (\\) in front; e.g., \\frac{3}{4} would need to be \\\\frac{3}{4}. If you’re reading in mathematical text from an external CSV file, you do not need the extra backslash in the CSV file. If you need assistance in figuring out how to type up mathematics, please talk to Neil, Matt, or Dennis. Note: Double dollar sign delimiters are generally not recommended for displaying math as they can lead to unintended results. See: Writing Mathematics for MathJax. 3.5.4 [Game] Question Text The text used as a question in a game should NOT be wrapped in a Heading tag; wrap the text in a paragraph tag. 3.5.5 Label Text (Buttons, Sliders, Other Inputs and Alerts) By using the central CSS file, any text you included in/on buttons, dropdown menus, sliders, radio buttons, choices, and other inputs as well as alert messages and popups/rollovers, will automatically be styled correctly. Do not use heading tags, the paragraph tag, italics/emphasis, or boldface/strong with input labels. You may use these tags with popups/rollovers. 3.5.6 Feedback and Hint Text Again, let the central CSS file handle the styling of this type of text. 3.5.7 Text in R Plots Unfortunately, any text in R plots does not get controlled by CSS. This means that you’ll have to play around with the settings. Using the ggplot2 package to make your plots (or other packages based upon the ggplot framework) will allow you to use the theme aspect to control text in your App. Here is an example for how to do this: # Create a ggplot2 object g1 &lt;- ggplot2::ggplot(data=df, aes(x=x, y=y, color=grp)) # Add your layers, for example g1 + ggplot2::geom_point() # Use theme to control text size g1 + ggplot2::theme( plot.caption = element_text(size = 18), text = element_text(size = 18) ) You will need to play around with the settings to find the appropriate value; text size 18 appears to work out well in many cases. Note: The text in your plot might not behave well for dynamic resizing on different mobile devices. 3.6 Graphics One of the most powerful tools we have in Statistics and Data Science is graphics. This includes images/pictures, graphs/plots, and tables. You will want to make sure that all graphical elements are appropriately sized in the Body. If there is text in a static image/picture, you’ll need to make sure that the text is legible on a variety of screen sizes. We’ve already discussed both issues of color and text size in plots. For additional considerations, please refer to the following readings (ordered from most important to least): Tufte-Fundamental Principles of Analytical Design Tufte-Chartjunk Kosslyn-Looking with the Eye and Mind Remember, we always want to be modeling excellent graphing behaviors. All photographs can be fortified with words. –Dorothea Lange A picture is worth a thousand words…but which ones. –Unknown Both of these quotations highlight that you need to include some text with your plots to help the user construct their understanding of what you’re trying to show them. 3.6.1 Axes and Scales R’s default axes are terrible. They often do not fully cover the data and the have gaps between the axes. All this impedes the user’s construction of meaning. Thus, you’ll want to take control and stipulate the axes and scales to optimize what users get out of the plot. If you are providing multiple plots that the user is supposed to compare, make sure that they all use the same scaling and axes. To force ggplot2 to place (0, 0) in the lower-left corner and to control the scales, you will need to include the following: # Create the ggplot2 object g1 &lt;- ggplot2::ggplot(...) # Add your layer g1 + ggplot2::geom_point() # Control axes and scale ## Multplicative Scaling of the Horizontal (x) Axis ## Additive Scaling of the Vertical (y) Axis g1 + ggplot2::scale_x_continuous(expand = expansion(mult = c(1,2), add = 0)) + scale_y_continuous(expand = expansion(mult = 0, add = c(0,0.05))) 3.6.2 Tables Data tables can pose a challenge for individuals to comprehend. Just as a wall of text isn’t conducive to helping a person understand what’s going on, neither is a wall of data values. Thus, we need to be extreme judicious about incorporating data tables into any of our apps. In web development there are two main types of tables: layout tables and data tables. Layout tables help to control where different elements appear on the page. We need an additional distinction for data tables: Summary Data Tables are tables that have summary information; typified by two-way tables (a.k.a. contingency tables or crosstabs) but might also include other things such as values of descriptive statistics stratified by groups. Data Set are an entire data object, presented in tabular format Layout Tables should never be used in a BOAST App. Data Sets should be displayed as sparingly as possible. In order to include a Data Set display, you will need to have identified an explicit learning goal/objective that necessitates the user digging through a data frame. If you can’t identify such a learning goal, you should NOT include a data frame. If the goal is to allow the user to look through the data set OR to have access to the data, then give a link to either the original source of the data (preferred) or for them to download the file. Summary Data Tables can be used more often and can enrich the user’s experience with your app. However, these must still be constructed in an appropriate manner. Neither Data Sets nor Summary Data Tables should be inserted into your App as a picture. This is an big Accessibility violation. Use the directions below to create the appropriate type of data table. 3.6.2.1 Displaying Data Tables Your first step is to create a data frame object in your R code. If you are displaying a data set (rare), then you will either need to read in the data or call that data frame. For this example, I’ll be using the mtcars data frame that is part of R. If you are making a Summary Data Table, you’ll need to either use R to calculate the values and store in a data frame or create a data frame yourself. In either case, be sure you identify what columns you’re going to use. If your original data file has 50 columns, but your App only makes use of 5, drop the the other 45. Only display the columns that you actually use. Your next step is to decide on where to put this display (e.g., inside an Exploration Tab or as a separate page). This will help you identify where in your App’s UI section you need to put the appropriate code. To ensure that your data table is accessible and responsive (i.e., mobile friendly), you will need to use the DT package. install.packages(&quot;DT&quot;) # Be sure to include this in your library call library(DT) In your UI section, you’ll need to use the following code, placed in the appropriate area: # [code omitted] DT::DTOutput(outputId = &quot;mtCars&quot;) # [code omitted] Then, in your Server section, you’ll need to use the following code: # [code omitted] # Prepare your data set with only the columns needed carData &lt;- mtcars[,c(&quot;mpg&quot;, &quot;cyl&quot;, &quot;hp&quot;, &quot;gear&quot;, &quot;wt&quot;)] ## Use Short but Meaningful Column Names names(carData) &lt;- c(&quot;MPG&quot;, &quot;# of Cylinders&quot;, &quot;Horsepower&quot;, &quot;# of Gears&quot;, &quot;Weight&quot;) # Create the output data table # Be sure to use the same name as you did in the UI output$mtCars &lt;- DT::renderDT( expr = carData, caption = &quot;Motor Trend US Data, 1973-1974 Models&quot;, # Add a caption to your table style = &quot;bootstrap4&quot;, # You must use this style rownames = TRUE, options = list( # You must use these options responsive = TRUE, # allows the data table to be mobile friendly scrollX = TRUE, # allows the user to scroll through a wide table columnDefs = list( # These will set alignment of data values # Notice the use of ncol on your data frame; leave the 1 as is. list(className = &#39;dt-center&#39;, targets = 1:ncol(carData)) ) ) ) # [code omitted] If you are making a Summary Data Table, you will need to follow the same process. If your data frame does not have row names, but instead a column with values acting as row names, you may replace the rownames = TRUE with rownames = FALSE; there should not be a column of sequential numbers on the left. Column names MUST be simple and meaningful to the user. To this end, you should rename any columns that might have poor choices for names, just as we have done with the mtcars data. This includes using Greek characters in isolation. You should not have any columns labeled \\(\\mu\\) or \\(\\sigma\\). Rather you need to use English words. Note: getting mathematical expressions to render properly in graphical environments in R is not as easy as in the paragraphs or headers of an app. Only certain graphing packages support limited mathematical expressions. The same is true for table generation packages. Again, try to use tables as infrequently as possible. Poorly constructed tables can create accessibility issues causing screen readers to poorly communicate tables to your users. If you run into problems and/or have questions, talk to Neil and Bob. 3.6.3 Static Images Static image refers to any image you’re using in your App which is not produced by R. These are usually PNG or JPG/JPEG files which you end up calling in the UI portion of your code. Within your App’s folder/directory, there needs to be a sub-folder/directory called www. This is the place where you’ll need to place ALL static image files. 3.6.3.1 Adding an Image To include the image in your App, you’ll need to make use of the image tag, img. When you run your App, Shiny automatically knows to check the www folder any time the img tag gets called. Here is an example supposing that the check mark image for correct answers is in the app’s www folder: #[code omitted] div(align = &quot;right&quot;, img(src = &quot;check.PNG&quot;, alt = &quot;Success, you are correct&quot;, width = 25, #these are in pixels height = 25, )) #[code omitted] You’ll notice that we’ve wrapped the img call in a div call. The div call allows us to specify that we want the image to be right aligned; you could also do left or center. You can replace the div call with the paragraph environment and include text on either side, effectively making your image part of the text. #[code omitted] p(&quot;Check your answer here --&gt;&quot;, img(src = &quot;check.PNG&quot;, alt = &quot;Success, you are correct&quot;, width = 25, height = 25), &quot;&lt;-- Check your answer here&quot;), #[code omitted] 3.6.3.2 Sizing and Positioning Your Image All image files have a native size that is part of that file. For instance, the check mark image is 270 x 250 pixels. However, we overrode that that sizing with the width and height arguments. How did we decide on 25 x 25? Honestly, through guess and checking. You’ll need to think about how you’re using the image and let that guide your decision making. There is no one size fits all solution. While finding an optimal size and position for your image can take some time, seeing bad settings is pretty obvious. Feel free to reach out to Neil and Bob for assistance. 3.6.4 Alt Text Any graphical element you include in your App MUST have an alternative (assistive) text description (“alt text”). This provides a short description of what is in the image or plot for users who are visual impaired. (Tables, when properly formatted will handle this automatically.) Here are several resources worth checking out: WebAIM Alternative Text Guide Penn State’s Image ALT Text Page W3C’s ALT Text Decision Tree 3.6.4.1 Adding Alt Text to Static Images In the prior section on static images, you saw exactly how to set the alt text; here is a generic example: #[code omitted] img(src = &quot;yourImage.PNG&quot;, alt = &quot;Short description of what&#39;s in the pic&quot;, width = 25, height = 25) #[code omitted] 3.6.4.2 Adding Alt Text Graphs This section is under construction. 3.7 Miscellaneous Consider adding a loading bar to show the process for intense computations; this will help the user understand that your App is processing and not frozen/broken. "]
]
